let VERSION="Shelly-3.0.0-rc1";let CONFIG={updatePeriod: 15000,apiEndpoint: "https://api.porssari.fi/getcontrols.php",registrationApiEndpoint: "https://api.porssari.fi/device_registration.php",returnTimestamps: 10,jsonVersion: 3,jsonChannelNames: false,logLevel: 0,};let shellyApp,shellyMac,shellyFwVer,scriptId,deviceChannels,storageType;let currentUnixTime,jsonValidUntil,shellyUptime;let lastRequest,lastRequestHttpCode;let controlsData=virtualStatesReady=controlsInitialized=isTaskBusy=isTaskDelay=isFailsafe=false;let mainCycleCounter=20;let cyclesUntilRequest=20;let mainTimer;let channelLastControlTimeStamps=[];let relayStates=[];let taskQueue=[];let scheduleCache=null;let channelDataCache=null;let virtualTime=0;let timeIsTrusted=false;let lastUptime=null;let lastVirtualTimeSave=0;let evVirtualChannelId=201;let evVirtualSwitchId=null;let evVirtualState=null;let evVirtualName=null;let estateId=null;let porssariRegistrationChecked=false;let porssariRegistrationPending=false;let porssariCredentialsComponentsCreated=false;let estateIdEventHandler=null;let estateIdRequestHandler=null;let porssariUsernameHandle=null;let porssariSecretHandle=null;let porssariCredentialsStatusHandler=null;const LOG={DEBUG: 0,INFO: 1,WARN: 2,ERROR: 3};function init(){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Pörssäri Control Script,version: "+VERSION);try{(CONFIG.logLevel<=LOG.INFO)&&console.log("Retrieving device information...");enqueueTask('shellycall','Shelly.GetDeviceInfo',{},InitCallback);}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("An error occurred while retrieving device information. Stopping script. "+e);return;}}function InitCallback(result){shellyApp=result.app;shellyMac=result.mac;shellyFwVer=result.ver;result=null;scriptId=(parseFloat(shellyFwVer)>=1.5)? Script.id : Shelly.getCurrentScriptId();if(shellyMac.length>0){(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Device info: device "+shellyApp+",id "+shellyMac+",firmware version "+shellyFwVer+",script-id "+scriptId);}else{(CONFIG.logLevel<=LOG.ERROR)&&console.log("Could not get valid device information. Stopping script.");return;}storageType=parseFloat(shellyFwVer)>=1.5 ? "ScriptStorage" : "None";InitPorssariRegistration();mainTimer=Timer.set(CONFIG.updatePeriod,true,MainCycle);if(!mainTimer){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Main timer not initialized. Stopping script.");}else{(CONFIG.logLevel<=LOG.INFO)&&console.log("Program loop timer initialized");}(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Calling startup function in 1 seconds: Load controls data from storage.");Timer.set(1000,false,LoadSavedControldata);}function LoadSavedControldata(){(CONFIG.logLevel<=LOG.INFO)&&console.log("Checking for existing data in local storage...");try{GetStorageValue('metadata',LoadSavedControldataCallback);}catch(e){(CONFIG.logLevel<=LOG.INFO)&&console.log("Saved data not found in local storage: "+e);}}function LoadSavedControldataCallback(result){if(!result){(CONFIG.logLevel<=LOG.INFO)&&console.log("Saved control data not found from local storage.");return;}let data;try{data=JSON.parse(result);result=null;if(!data||typeof data!=="object"){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Invalid JSON structure in saved data.");return;}deviceChannels=data.channels;lastRequest=data.timestamp;jsonValidUntil=data.valid_until;data=null;(CONFIG.logLevel<=LOG.INFO)&&console.log("Found controls data from local storage.");controlsData=true;controlsReady=true;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Controlled channels: "+deviceChannels+",valid until: "+jsonValidUntil+",api endpoint: "+CONFIG.apiEndpoint);LoadVirtualTimeFromStorage();}catch(e){(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Saved control data not found from local storage: "+e);}}function SetStorageValue(baseKey,value){if(storageType!=="ScriptStorage"){(CONFIG.logLevel<=LOG.INFO)&&console.log("Local storage not supported for this firmware,skipping save for key "+baseKey);return;}let chunkSize=1000;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Saving data "+baseKey+" to "+storageType+" with chunk size: "+chunkSize);if(!value){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Error while saving data to local storage: Value not given");return;}value=btoa(JSON.stringify(value));let parts=Math.ceil(value.length/chunkSize);let chunks=[];for(let i=0;i<parts;i++){let chunk=value.substring(i*chunkSize,(i+1)*chunkSize);let key=baseKey+"_"+i;chunks[key]=chunk;chunk=null;}value=null;try{(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Check for previous chunks count for key "+baseKey);let previousParts=0;for(let i=0;i<Script.storage.length;i++){const key=Script.storage.key(i);if(key.indexOf(baseKey)===0){previousParts+=1;}}(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Found "+previousParts+" chunks from ScriptStorage for key "+baseKey);SetStorageValueCallback(baseKey,chunks,parts,previousParts);}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Error retrieving previous chunks for key "+baseKey+": "+e);SetStorageValueCallback(baseKey,chunks,parts,0);}}function SetStorageValueCallback(baseKey,chunks,parts,previousParts){if(storageType!=="ScriptStorage"){(CONFIG.logLevel<=LOG.INFO)&&console.log("Local storage not supported for this firmware,skipping save for key "+baseKey);return;}for(let key in chunks){Script.storage.setItem(key,chunks[key]);(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Saved to ScriptStorage: "+key);chunks[key]=null;}chunks=null;if(previousParts>parts){(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Removing "+(previousParts-parts)+" old chunks.");for(let i=parts;i<previousParts;i++){let key=baseKey+"_"+i;Script.storage.removeItem(key);(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Removed chunk: "+key+" from ScriptStorage");}}}function GetStorageValue(baseKey,callback){if(storageType!=="ScriptStorage"){(CONFIG.logLevel<=LOG.INFO)&&console.log("Local storage not supported for this firmware,returning no data for key "+baseKey);callback(null);return;}let parts=0;for(let i=0;i<Script.storage.length;i++){const key=Script.storage.key(i);if(key.indexOf(baseKey)===0){parts+=1;}}let fullValue="";for(let i=0;i<parts;i++){let keyToFind=baseKey+"_"+i;for(let j=0;j<Script.storage.length;j++){const key=Script.storage.key(j);if(key===keyToFind){fullValue+=Script.storage.getItem(key);break;}}}callback(atob(fullValue));callback=null;fullValue=null;}function InitPorssariRegistration(){if(porssariRegistrationChecked){return;}porssariRegistrationChecked=true;if(!CONFIG.registrationApiEndpoint||CONFIG.registrationApiEndpoint.length===0){(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Pörssäri registration endpoint not configured,skipping registration check.");return;}CheckDeviceRegistrationInPorssari();}function CheckDeviceRegistrationInPorssari(){try{let urlToCall=CONFIG.registrationApiEndpoint;(CONFIG.logLevel<=LOG.INFO)&&console.log("Checking Pörssäri registration status...");(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Registration URL: "+urlToCall);let postBody=JSON.stringify({deviceId: shellyMac,model: shellyApp,firmwareVersion: shellyFwVer,scriptVersion: VERSION});enqueueTask("shellycall","HTTP.POST",{"url": urlToCall,"timeout": 10,"ssl_ca": "*","headers":{"Content-Type": "application/json"},"body": postBody},CheckDeviceRegistrationInPorssariCallback);}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Error while checking Pörssäri registration status: "+e);}}function CheckDeviceRegistrationInPorssariCallback(res,errCode,errMsg){if(errCode!==0||!res){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Pörssäri registration check failed: "+errCode+"/"+errMsg);return;}try{if(res.code!==200){(CONFIG.logLevel<=LOG.INFO)&&console.log("Pörssäri registration status HTTP code: "+res.code);return;}let body=JSON.parse(res.body);res=null;if(!body||typeof body!=="object"){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Invalid Pörssäri registration JSON.");return;}let found=body.found!==undefined ? parseInt(body.found): 0;if(found===1&&body.building_id){estateId=""+body.building_id;(CONFIG.logLevel<=LOG.INFO)&&console.log("Pörssäri: device already registered to estateId "+estateId+".");StartEstateIdResponder();EmitPorssariBuildingIdToLan();(CONFIG.logLevel<=LOG.INFO)&&console.log("Pörssäri: estateId available,starting control data polling.");controlsReady=false;RequestControldata();}else{(CONFIG.logLevel<=LOG.INFO)&&console.log("Pörssäri: device not registered,waiting for building id from LAN or user.");StartListeningPorssariBuildingIdFromLan();}}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Error while parsing Pörssäri registration status: "+e);}}function EmitPorssariBuildingIdToLan(){if(!estateId){return;}if(typeof Shelly==="undefined"||typeof Shelly.emitEvent!=="function"){(CONFIG.logLevel<=LOG.WARN)&&console.log("Pörssäri: Shelly.emitEvent not available,cannot emit estateId.");return;}(CONFIG.logLevel<=LOG.INFO)&&console.log("Pörssäri: emitting estateId "+estateId+" via Shelly event.");try{Shelly.emitEvent("porssari_estate_id",{estateId: estateId,device_mac: shellyMac});}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Pörssäri: exception while emitting estateId event: "+e);}}function StartListeningPorssariBuildingIdFromLan(){(CONFIG.logLevel<=LOG.INFO)&&console.log("Pörssäri: listening for estateId events via Shelly.addEventHandler().");if(estateId){return;}if(typeof Shelly==="undefined"||typeof Shelly.addEventHandler!=="function"){(CONFIG.logLevel<=LOG.WARN)&&console.log("Pörssäri: Shelly.addEventHandler not available,cannot listen for estateId events.");}else{estateIdEventHandler=Shelly.addEventHandler(function(ev,userdata){try{if(!ev||!ev.event||ev.event!=="porssari_estate_id"){return;}if(!ev.data||typeof ev.data.estateId==="undefined"){return;}if(!estateId){OnPorssariBuildingIdReceived(ev.data.estateId);}}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Pörssäri: error in estateId event handler: "+e);}});if(typeof Shelly.emitEvent==="function"){try{(CONFIG.logLevel<=LOG.INFO)&&console.log("Pörssäri: emitting estateId request event.");Shelly.emitEvent("porssari_estate_id_request",{device_mac: shellyMac});}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Pörssäri: error while emitting estateId request event: "+e);}}}Timer.set(5000,false,function(){if(!estateId&&!porssariCredentialsComponentsCreated){CreatePorssariCredentialsVirtualComponents();}});}function OnPorssariBuildingIdReceived(buildingId){if(!buildingId){return;}estateId=""+buildingId;(CONFIG.logLevel<=LOG.INFO)&&console.log("Pörssäri: estateId received from LAN: "+estateId+". Registering device for adoption.");CleanupEstateIdListener();StartEstateIdResponder();RegisterDeviceForAdoptionInPorssari();(CONFIG.logLevel<=LOG.INFO)&&console.log("Pörssäri: estateId available,starting control data polling.");controlsReady=false;RequestControldata();}function StartEstateIdResponder(){if(!estateId){return;}if(typeof Shelly==="undefined"||typeof Shelly.addEventHandler!=="function"||typeof Shelly.emitEvent!=="function"){(CONFIG.logLevel<=LOG.WARN)&&console.log("Pörssäri: cannot start estateId responder,Shelly event API not available.");return;}if(estateIdRequestHandler){return;}estateIdRequestHandler=Shelly.addEventHandler(function(ev,userdata){try{if(!ev||!ev.event||ev.event!=="porssari_estate_id_request"){return;}if(ev.data&&ev.data.device_mac&&ev.data.device_mac===shellyMac){return;}(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Pörssäri: answering estateId request with estateId "+estateId+".");EmitPorssariBuildingIdToLan();}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Pörssäri: error in estateId request handler: "+e);}});}function RegisterDeviceForAdoptionInPorssari(){if(!estateId){(CONFIG.logLevel<=LOG.WARN)&&console.log("Pörssäri: cannot register device for adoption,estateId missing.");return;}if(porssariRegistrationPending){return;}porssariRegistrationPending=true;try{let urlToCall=CONFIG.registrationApiEndpoint;(CONFIG.logLevel<=LOG.INFO)&&console.log("Pörssäri: registering device for adoption,estateId "+estateId+"...");(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Pörssäri registration URL: "+urlToCall);let postBody=JSON.stringify({deviceId: shellyMac,estateId: estateId,model: shellyApp,firmwareVersion: shellyFwVer,scriptVersion: VERSION});enqueueTask("shellycall","HTTP.POST",{"url": urlToCall,"timeout": 10,"ssl_ca": "*","headers":{"Content-Type": "application/json"},"body": postBody},RegisterDeviceForAdoptionInPorssariCallback);}catch(e){porssariRegistrationPending=false;(CONFIG.logLevel<=LOG.ERROR)&&console.log("Error while registering device for adoption in Pörssäri: "+e);}}function RegisterDeviceForAdoptionInPorssariCallback(res,errCode,errMsg){porssariRegistrationPending=false;if(errCode!==0||!res){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Pörssäri adoption registration failed: "+errCode+"/"+errMsg);return;}try{(CONFIG.logLevel<=LOG.INFO)&&console.log("Pörssäri adoption registration response code: "+res.code);if(res.code===200&&estateId){CleanupPorssariCredentialsComponents();}}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Error while handling Pörssäri adoption registration response: "+e);}}function CreatePorssariCredentialsVirtualComponents(){if(porssariCredentialsComponentsCreated){return;}if(estateId){return;}if(typeof Virtual==="undefined"||typeof Virtual.Add!=="function"||typeof Virtual.getHandle!=="function"){(CONFIG.logLevel<=LOG.WARN)&&console.log("Pörssäri: Virtual component API not available,cannot create credentials components.");return;}try{let usernameResult=Virtual.Add({type: "text",config:{name: "porssari_username"},id: 210});let secretResult=Virtual.Add({type: "text",config:{name: "porssari_secret"},id: 211});(CONFIG.logLevel<=LOG.INFO)&&console.log("Pörssäri: virtual components for username and secret created(text:210,text:211).");(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Pörssäri: usernameResult="+JSON.stringify(usernameResult)+",secretResult="+JSON.stringify(secretResult));try{porssariUsernameHandle=Virtual.getHandle("text:210");porssariSecretHandle=Virtual.getHandle("text:211");}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Pörssäri: error getting virtual component handles: "+e);}StartListeningPorssariCredentialsChanges();porssariCredentialsComponentsCreated=true;}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Pörssäri: error while creating credentials virtual components: "+e);}}function StartListeningPorssariCredentialsChanges(){if(porssariCredentialsStatusHandler){return;}if(typeof Shelly==="undefined"||typeof Shelly.addStatusHandler!=="function"){(CONFIG.logLevel<=LOG.WARN)&&console.log("Pörssäri: Shelly.addStatusHandler not available,cannot listen for credential changes.");return;}porssariCredentialsStatusHandler=Shelly.addStatusHandler(function(status,userdata){try{if(!status||!status.virtual||!status.virtual.text){return;}let username=null;let passcode=null;if(status.virtual.text[210]&&status.virtual.text[210].value){username=status.virtual.text[210].value;}if(status.virtual.text[211]&&status.virtual.text[211].value){passcode=status.virtual.text[211].value;}if(username&&passcode&&!estateId&&!porssariRegistrationPending){(CONFIG.logLevel<=LOG.INFO)&&console.log("Pörssäri: credentials filled,registering device with username and passcode.");RegisterDeviceWithCredentialsInPorssari(username,passcode);}}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Pörssäri: error in credentials status handler: "+e);}});}function RegisterDeviceWithCredentialsInPorssari(username,passcode){if(!username||!passcode){(CONFIG.logLevel<=LOG.WARN)&&console.log("Pörssäri: cannot register device,username or passcode missing.");return;}if(porssariRegistrationPending){return;}porssariRegistrationPending=true;try{let urlToCall=CONFIG.registrationApiEndpoint;(CONFIG.logLevel<=LOG.INFO)&&console.log("Pörssäri: registering device with credentials...");(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Pörssäri registration URL: "+urlToCall);let postBody=JSON.stringify({deviceId: shellyMac,username: username,passcode: passcode,model: shellyApp,firmwareVersion: shellyFwVer,scriptVersion: VERSION});enqueueTask("shellycall","HTTP.POST",{"url": urlToCall,"timeout": 10,"ssl_ca": "*","headers":{"Content-Type": "application/json"},"body": postBody},RegisterDeviceWithCredentialsCallback);}catch(e){porssariRegistrationPending=false;(CONFIG.logLevel<=LOG.ERROR)&&console.log("Error while registering device with credentials in Pörssäri: "+e);}}function RegisterDeviceWithCredentialsCallback(res,errCode,errMsg){porssariRegistrationPending=false;if(errCode!==0||!res){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Pörssäri credentials registration failed: "+errCode+"/"+errMsg);return;}try{if(res.code===200){let body=JSON.parse(res.body);res=null;if(body&&body.estateId){estateId=""+body.estateId;(CONFIG.logLevel<=LOG.INFO)&&console.log("Pörssäri: device registered successfully,estateId: "+estateId+".");CleanupEstateIdListener();CleanupPorssariCredentialsComponents();StartEstateIdResponder();EmitPorssariBuildingIdToLan();(CONFIG.logLevel<=LOG.INFO)&&console.log("Pörssäri: estateId available,starting control data polling.");controlsReady=false;RequestControldata();}else{(CONFIG.logLevel<=LOG.INFO)&&console.log("Pörssäri credentials registration response code: "+res.code);}}else{(CONFIG.logLevel<=LOG.INFO)&&console.log("Pörssäri credentials registration response code: "+res.code);}}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Error while handling Pörssäri credentials registration response: "+e);}}function CleanupEstateIdListener(){if(estateIdEventHandler&&typeof Shelly!=="undefined"&&typeof Shelly.removeEventHandler==="function"){try{Shelly.removeEventHandler(estateIdEventHandler);estateIdEventHandler=null;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Pörssäri: estateId event listener removed.");}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Pörssäri: error removing estateId event listener: "+e);}}}function CleanupPorssariCredentialsComponents(){if(porssariCredentialsStatusHandler&&typeof Shelly!=="undefined"&&typeof Shelly.removeStatusHandler==="function"){try{Shelly.removeStatusHandler(porssariCredentialsStatusHandler);porssariCredentialsStatusHandler=null;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Pörssäri: credentials status handler removed.");}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Pörssäri: error removing credentials status handler: "+e);}}if(porssariCredentialsComponentsCreated&&typeof Shelly!=="undefined"&&typeof Shelly.removeComponent==="function"){try{Shelly.removeComponent("text:210");(CONFIG.logLevel<=LOG.INFO)&&console.log("Pörssäri: virtual component text:210(username)removed.");}catch(e){(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Pörssäri: error removing username component(may not exist): "+e);}try{Shelly.removeComponent("text:211");(CONFIG.logLevel<=LOG.INFO)&&console.log("Pörssäri: virtual component text:211(secret)removed.");}catch(e){(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Pörssäri: error removing secret component(may not exist): "+e);}porssariCredentialsComponentsCreated=false;porssariUsernameHandle=null;porssariSecretHandle=null;}}function SaveVirtualTimeToStorage(){if(storageType!=="ScriptStorage"){return;}if(!timeIsTrusted||!virtualTime||virtualTime<=0){return;}let payload={virtual_time: virtualTime};if(jsonValidUntil){payload.json_valid_until=jsonValidUntil;}if(lastRequest){payload.last_request=lastRequest;}try{SetStorageValue('virtualtime',payload);(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Virtual time saved to storage: "+virtualTime);}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Error while saving virtual time to storage: "+e);}}function LoadVirtualTimeFromStorage(){if(storageType!=="ScriptStorage"){return;}try{GetStorageValue('virtualtime',function(result){if(!result){(CONFIG.logLevel<=LOG.DEBUG)&&console.log("No virtual time found in storage.");return;}try{let data=JSON.parse(result);result=null;if(data&&typeof data==="object"&&data.virtual_time!==undefined){let vt=parseInt(data.virtual_time);if(!isNaN(vt)&&vt>0){virtualTime=vt;timeIsTrusted=true;lastVirtualTimeSave=virtualTime;currentUnixTime=virtualTime;(CONFIG.logLevel<=LOG.INFO)&&console.log("Virtual time loaded from storage: "+virtualTime);}}}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Error parsing virtual time from storage: "+e);}});}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Error while loading virtual time from storage: "+e);}}function UpdateVirtualTime(){let uptime=null;try{if(typeof Shelly!=="undefined"&&typeof Shelly.getComponentStatus==="function"){let sys=Shelly.getComponentStatus("sys",0);if(sys&&typeof sys.uptime!=="undefined"){uptime=parseInt(sys.uptime);}}}catch(e){(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Error while reading system uptime: "+e);}if(uptime===null||isNaN(uptime)||uptime<0){if(!timeIsTrusted||virtualTime<=0){virtualTime=Math.floor(Date.now()/1000);timeIsTrusted=true;currentUnixTime=virtualTime;}return;}if(lastUptime===null){lastUptime=uptime;if(!timeIsTrusted||virtualTime<=0){virtualTime=Math.floor(Date.now()/1000);timeIsTrusted=true;}currentUnixTime=virtualTime;return;}let delta=uptime-lastUptime;if(delta<=0){lastUptime=uptime;currentUnixTime=virtualTime;return;}virtualTime+=delta;lastUptime=uptime;currentUnixTime=virtualTime;}function MaybeSaveVirtualTime(){if(!timeIsTrusted||!virtualTime||virtualTime<=0){return;}if(lastVirtualTimeSave===0||(virtualTime-lastVirtualTimeSave)>=60){SaveVirtualTimeToStorage();lastVirtualTimeSave=virtualTime;}}function RequestControldata(){if(!estateId){(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Skipping control data request: device not registered(no estateId).");controlsReady=true;cyclesUntilRequest=18+Math.floor(3*Math.random());mainCycleCounter=1;return;}try{(CONFIG.logLevel<=LOG.INFO)&&console.log("Requesting control data from server...");let urlToCall=CONFIG.apiEndpoint+"?device_mac="+shellyMac+"&last_request="+(lastRequest||0)+"&script_version="+VERSION+"&client_model="+shellyApp+"&client_fw="+shellyFwVer+"&cut_schedule="+CONFIG.returnTimestamps+"&json_version="+CONFIG.jsonVersion+"&json_channel_names="+CONFIG.jsonChannelNames;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("URL: "+urlToCall);enqueueTask("shellycall","HTTP.GET",{"url": urlToCall,"timeout": 10,"ssl_ca": "*"},RequestControldataCallback);urlToCall=null;}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Error while requesting control data from server: "+e);controlsReady=true;cyclesUntilRequest=18+Math.floor(3*Math.random());mainCycleCounter=1;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Resetting request cycle counter. Cycles before next request: "+cyclesUntilRequest);}}function RequestControldataCallback(res,errCode,errMsg){let requestInfo;if(errCode!=0){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Request error: "+errCode,errMsg);return;}if(!res){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Invalid response: "+errCode,errMsg);return;}try{if(res.code===200){requestInfo='Get controls successful. Code 200.';let parsedBody=JSON.parse(res.body);res=null;let metadata=parsedBody.metadata;let schedule=parsedBody.controls;let channelData=parsedBody.channel_states;parsedBody=null;SetStorageValue('metadata',metadata);deviceChannels=parseInt(metadata.channels);CONFIG.apiEndpoint=metadata.fetch_url;lastRequest=parseInt(metadata.timestamp);jsonValidUntil=parseInt(metadata.valid_until);metadata=null;virtualTime=Math.floor(Date.now()/1000);timeIsTrusted=true;currentUnixTime=virtualTime;if(schedule&&Array.isArray(schedule)){schedule=sortFlatScheduleByTimestamp(schedule);if(storageType==="ScriptStorage"){SetStorageValue('schedule',schedule);scheduleCache=null;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Schedule stored to ScriptStorage,entries: "+schedule.length);}else{scheduleCache=schedule;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Schedule cached in memory,entries: "+scheduleCache.length);}}else{if(storageType!=="ScriptStorage"){scheduleCache=null;}(CONFIG.logLevel<=LOG.DEBUG)&&console.log("No schedule object found in JSON response.");}schedule=null;if(channelData&&typeof channelData==="object"){let mappedChannelData={};for(let i=0;i<channelData.length;i++){let chEntry=channelData[i];if(!chEntry||chEntry.id===undefined)continue;let chId=parseInt(chEntry.id);if(isNaN(chId)||chId<=0)continue;let switchId=chId-1;mappedChannelData[switchId]={state: chEntry.state!==undefined ? parseInt(chEntry.state): 0,updated: chEntry.updated!==undefined ? parseInt(chEntry.updated): 0,name: chEntry.name||""};}channelDataCache=mappedChannelData;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Channel data cache loaded.");}else{channelDataCache=null;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("No channel_data object found in JSON response.");}HandleEvVirtualComponent(channelData);channelData=null;SaveVirtualTimeToStorage();controlsData=true;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Controls JSON parsed.");(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Controlled channels: "+deviceChannels+",valid until: "+jsonValidUntil+",api endpoint: "+CONFIG.apiEndpoint);}else if(res.code===204){requestInfo="Device found from server without associated loads: "+res.code;res=null;}else if(res.code===304){requestInfo="Controls data not updated after last request: "+res.code;res=null;virtualTime=Math.floor(Date.now()/1000);timeIsTrusted=true;currentUnixTime=virtualTime;SaveVirtualTimeToStorage();}else{requestInfo="Invalid server request. Code: "+res.code;res=null;}}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Control data request failed: "+e)}(CONFIG.logLevel<=LOG.INFO)&&console.log("Server request done. "+requestInfo);requestInfo=null;controlsReady=true;cyclesUntilRequest=18+Math.floor(3*Math.random());mainCycleCounter=1;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Resetting request cycle counter. Cycles before next request: "+cyclesUntilRequest);}function CheckControlData(){(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Checking if control data is valid.");isFailsafe=false;if(controlsData&&jsonValidUntil<=currentUnixTime){(CONFIG.logLevel<=LOG.INFO)&&console.log("The control schedule is empty. Activating failsafe mode.");isFailsafe=true;}if(!controlsData){(CONFIG.logLevel<=LOG.INFO)&&console.log("Control data not available. Activating failsafe mode.");isFailsafe=true;}if(isFailsafe){if(mainCycleCounter>cyclesUntilRequest){cyclesUntilRequest=18+Math.floor(3*Math.random());mainCycleCounter=1;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Resetting request cycle counter. Cycles before next request: "+cyclesUntilRequest);}return;}(CONFIG.logLevel<=LOG.INFO)&&console.log("Control data is valid for "+parseInt((jsonValidUntil-currentUnixTime)/60)+" minutes");}function DoControls(){(CONFIG.logLevel<=LOG.INFO)&&console.log("Updating virtual states for relays...");virtualStatesReady=false;if(storageType==="ScriptStorage"){GetStorageValue('schedule',DoControlsCallback);}else{DoControlsCallback(null);}}function DoControlsCallback(value){let schedule=null;try{if(storageType==="ScriptStorage"){if(value){schedule=JSON.parse(value);value=null;}}else{if(scheduleCache&&Array.isArray(scheduleCache)){schedule=scheduleCache;}}}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Error parsing schedule JSON: "+e);virtualStatesReady=true;return;}if(!schedule||!Array.isArray(schedule)||schedule.length===0){(CONFIG.logLevel<=LOG.INFO)&&console.log("No valid schedule found,virtual states not updated.");schedule=null;virtualStatesReady=true;return;}(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Found schedule data,updating virtual states...");if(!controlsInitialized){(CONFIG.logLevel<=LOG.INFO)&&console.log("Script has started,initializing virtual states...");try{let baseState=[];let baseTimestamp=[];for(let ch=1;ch<=deviceChannels;ch++){let switchId=ch-1;baseState[switchId]=0;baseTimestamp[switchId]=lastRequest||0;if(channelDataCache&&channelDataCache[switchId]){if(channelDataCache[switchId].state!==undefined){baseState[switchId]=parseInt(channelDataCache[switchId].state);}if(channelDataCache[switchId].updated!==undefined){let updTs=parseInt(channelDataCache[switchId].updated);if(!isNaN(updTs)&&updTs>baseTimestamp[switchId]){baseTimestamp[switchId]=updTs;}}}(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Relay "+ch+": initializing,base state from channel_data: "+baseState[switchId]+",base ts: "+baseTimestamp[switchId]);}for(let i=0;i<schedule.length;i++){let row=schedule[i];let ts=parseInt(row[0]);if(isNaN(ts)||ts>=currentUnixTime){continue;}let ch=parseInt(row[1]);let state=parseInt(row[2]);if(isNaN(ch)||ch<=0){continue;}let switchId=ch-1;if(ts>=baseTimestamp[switchId]){baseState[switchId]=state;baseTimestamp[switchId]=ts;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Relay "+ch+": passed timestamp: "+ts+",state: "+state);}}for(let ch=1;ch<=deviceChannels;ch++){let switchId=ch-1;updateVirtualState(switchId,baseState[switchId]);channelLastControlTimeStamps[switchId]=baseTimestamp[switchId];}controlsInitialized=true;schedule=null;virtualStatesReady=true;(CONFIG.logLevel<=LOG.INFO)&&console.log("Virtual states initialized.");return;}catch(e){controlsInitialized=false;schedule=null;virtualStatesReady=true;(CONFIG.logLevel<=LOG.ERROR)&&console.log("Error while initializing virtual states from schedule: "+e);return;}}(CONFIG.logLevel<=LOG.INFO)&&console.log("Reading schedule or updated state from channel_data...");try{let lastTsPerChannel=[];let newTsPerChannel=[];let newStatePerChannel=[];let useChannelDataOverride=[];for(let ch=1;ch<=deviceChannels;ch++){let switchId=ch-1;let lastTs=parseInt(channelLastControlTimeStamps[switchId]||0);lastTsPerChannel[switchId]=lastTs;newTsPerChannel[switchId]=lastTs;newStatePerChannel[switchId]=null;useChannelDataOverride[switchId]=false;let updatedTs=0;let currentStateFromChannelData=null;if(channelDataCache&&channelDataCache[switchId]){if(channelDataCache[switchId].updated!==undefined){updatedTs=parseInt(channelDataCache[switchId].updated);}if(channelDataCache[switchId].state!==undefined){currentStateFromChannelData=parseInt(channelDataCache[switchId].state);}}(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Relay "+ch+": channel_data updated: "+updatedTs+",last controlled timestamp: "+lastTs);if(updatedTs>lastTs&&currentStateFromChannelData!==null){useChannelDataOverride[switchId]=true;newStatePerChannel[switchId]=currentStateFromChannelData;newTsPerChannel[switchId]=currentUnixTime;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Relay "+ch+": will switch directly to channel_data state "+currentStateFromChannelData+" at ts "+currentUnixTime);}}for(let i=0;i<schedule.length;i++){let row=schedule[i];let ts=parseInt(row[0]);if(isNaN(ts)||ts>currentUnixTime){continue;}let ch=parseInt(row[1]);let state=parseInt(row[2]);if(isNaN(ch)||ch<=0){continue;}let switchId=ch-1;if(useChannelDataOverride[switchId]){continue;}let lastTs=lastTsPerChannel[switchId];if(ts>lastTs&&ts>=newTsPerChannel[switchId]){newTsPerChannel[switchId]=ts;newStatePerChannel[switchId]=state;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Relay "+ch+": candidate passed timestamp: "+ts+",state: "+state);}}for(let ch=1;ch<=deviceChannels;ch++){let switchId=ch-1;let newTs=newTsPerChannel[switchId];let lastTs=lastTsPerChannel[switchId];let state=newStatePerChannel[switchId];if(state!==null&&newTs>lastTs){updateVirtualState(switchId,state);channelLastControlTimeStamps[switchId]=newTs;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Relay "+ch+": final control timestamp: "+newTs+",state: "+state);}else{(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Relay "+ch+": no new control actions needed.");}}(CONFIG.logLevel<=LOG.INFO)&&console.log("Virtual states updated.");}catch(e){(CONFIG.logLevel<=LOG.INFO)&&console.log("Virtual states not updated due to unknown error while reading schedule: "+e);}channelDataCache=null;schedule=null;virtualStatesReady=true;}function updateVirtualState(switchId,state){if(!relayStates[switchId]){relayStates[switchId]={id: null,virtualState: 0,realState: 0,inputState: 0,updated: false,checked: false};}relayStates[switchId].virtualState=state;relayStates[switchId].id=switchId;relayStates[switchId].updated=true;relayStates[switchId].checked=false;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Updated virtualState for switch "+switchId+": new virtual state: "+relayStates[switchId].virtualState);}function CheckRelayStates(){if(!relayStates){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Could not find any controlled relays.");return;}let relayKeys=Object.keys(relayStates);if(!relayKeys||relayKeys.length==0){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Could not find any controlled relays.");return;}(CONFIG.logLevel<=LOG.INFO)&&console.log("Checking relay states...");for(let relayEntry in relayKeys){let switchId=relayStates[relayEntry].id;enqueueTask("shellycall","Switch.GetStatus",{id: switchId},CheckRelayStatesCallback);}}function CheckRelayStatesCallback(res,errCode,errMsg){if(errCode!==0||!res){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Error with switch data."+errMsg);return;}try{let switchId=parseInt(res.id);relayStates[switchId].realState=res.output ? 1 : 0;let inputState=0;if(typeof res.input!=="undefined"){inputState=res.input ? 1 : 0;}if(!relayStates[switchId]){relayStates[switchId]={id: switchId,virtualState: 0,realState: 0,inputState: inputState,updated: false,checked: false};}else{relayStates[switchId].inputState=inputState;}res=null;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Updated state information for switch "+switchId+": virtual state: "+relayStates[switchId].virtualState+",real state: "+relayStates[switchId].realState+",updated: "+relayStates[switchId].updated+",checked: "+relayStates[switchId].checked);if(relayStates[switchId].updated){(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Virtual state updated for switch "+switchId+",executing controls...");let state=relayStates[switchId].virtualState;if(state===0&&relayStates[switchId].inputState===1){let relay=switchId+1;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Relay "+relay+": virtual OFF ignored because external switch is ON.");relayStates[switchId].updated=false;relayStates[switchId].checked=true;return;}enqueueTask("shellycall","Switch.Set",{"id": switchId,"on": state===1 ? true : false},function(){relayStates[switchId].updated=false;let relay=switchId+1;(CONFIG.logLevel<=LOG.INFO)&&console.log("Relay "+relay+": switched to state: "+state);});return;}if((!relayStates[switchId].checked)&&(relayStates[switchId].virtualState!==relayStates[switchId].realState)){(CONFIG.logLevel<=LOG.DEBUG)&&console.log("State not updated correctly for switch "+switchId+",executing controls...");let state=relayStates[switchId].virtualState;if(state===0&&relayStates[switchId].inputState===1){let relay=switchId+1;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Relay "+relay+": virtual OFF ignored because external switch is ON.");relayStates[switchId].updated=false;relayStates[switchId].checked=true;return;}enqueueTask("shellycall","Switch.Set",{"id": switchId,"on": state===1 ? true : false},function(){relayStates[switchId].updated=false;(CONFIG.logLevel<=LOG.INFO)&&console.log("Switch "+switchId+" set to state "+state);});return;}else if(!relayStates[switchId].checked){let relay=switchId+1;(CONFIG.logLevel<=LOG.INFO)&&console.log("Relay "+relay+": state checked after passed timestamp.");relayStates[switchId].checked=true;}else if((relayStates[switchId].checked)&&(relayStates[switchId].virtualState!==relayStates[switchId].realState)){let relay=switchId+1;(CONFIG.logLevel<=LOG.INFO)&&console.log("Relay "+relay+": relay state is switched by user.");}else if(relayStates[switchId].checked){let relay=switchId+1;(CONFIG.logLevel<=LOG.INFO)&&console.log("Relay "+relay+": relay state is up to date.");}}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Error with switch data."+e);}}function enqueueTask(type,method,params,callback){const MAX_TASK_QUEUE_SIZE=50;if(taskQueue.length>=MAX_TASK_QUEUE_SIZE){(CONFIG.logLevel<=LOG.WARN)&&console.log("Task queue full("+taskQueue.length+"),dropping oldest task.");taskQueue.shift();}taskQueue.push({type: type,method: method,params: params,callback: callback||null});(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Tasks in queue: "+taskQueue.length);if(!isTaskBusy&&!isTaskDelay){processTaskQueue();}}function processTaskQueue(){if(isTaskBusy||taskQueue.length===0){isTaskDelay=false;return;}isTaskBusy=true;try{let taskToExecute=taskQueue[0];taskQueue.splice(0,1);(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Running task: "+taskToExecute.method+" with params: "+JSON.stringify(taskToExecute.params));if(taskToExecute.type==="shellycall"){Shelly.call(taskToExecute.method,taskToExecute.params,function(res,errCode,errMsg){if(taskToExecute.callback){(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Calling callback for "+taskToExecute.method);taskToExecute.callback(res,errCode,errMsg);taskToExecute.callback=null;}else{(CONFIG.logLevel<=LOG.DEBUG)&&console.log("No callback found for task: "+taskToExecute.method);}isTaskBusy=false;handleTaskQueueDelay(taskToExecute);});}else{(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Unknown task type: "+taskToExecute.type);isTaskBusy=false;handleTaskQueueDelay(taskToExecute);}}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Error with task: "+taskToExecute.method+" with params: "+JSON.stringify(taskToExecute.params)+": "+e);isTaskBusy=false;processTaskQueue()}}function handleTaskQueueDelay(task){if(taskQueue.length===0){task=null;(CONFIG.logLevel<=LOG.DEBUG)&&console.log("All tasks has been done.");return;}if(taskQueue[0].method==="Switch.Set"&&task.method==="Switch.Set"){(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Consecutive Switch.Set calls detected,setting a delay before the next call.");isTaskDelay=true;Timer.set(5000,false,function(){isTaskDelay=false;processTaskQueue();});}else{(CONFIG.logLevel<=LOG.DEBUG)&&console.log("No consecutive Switch.Set calls detected,proceeding without delay.");processTaskQueue();}}function sortFlatScheduleByTimestamp(schedule){let n=schedule.length;for(let i=0;i<n-1;i++){let minIndex=i;for(let j=i+1;j<n;j++){if(parseInt(schedule[j][0])<parseInt(schedule[minIndex][0])){minIndex=j;}}if(minIndex!==i){let tmp=schedule[i];schedule[i]=schedule[minIndex];schedule[minIndex]=tmp;}}return schedule;}function HandleEvVirtualComponent(channelData){if(typeof Shelly==="undefined"||typeof Shelly.addVirtualComponent!=="function"){(CONFIG.logLevel<=LOG.DEBUG)&&console.log("Virtual components are not supported on this firmware,skipping EV virtual switch handling.");return;}let evEntry=null;if(channelData&&typeof channelData==="object"){for(let i=0;i<channelData.length;i++){let chEntry=channelData[i];if(!chEntry||chEntry.id===undefined)continue;let chId=parseInt(chEntry.id);if(chId===evVirtualChannelId){evEntry=chEntry;break;}}}if(!evEntry){if(evVirtualSwitchId!==null){if(typeof Shelly.removeComponent==="function"){try{Shelly.removeComponent(evVirtualSwitchId);(CONFIG.logLevel<=LOG.INFO)&&console.log("EV virtual switch removed,id: "+evVirtualSwitchId);}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Error removing EV virtual switch: "+e);}}else{(CONFIG.logLevel<=LOG.WARN)&&console.log("Shelly.removeComponent not available,cannot remove EV virtual switch with id: "+evVirtualSwitchId);}}evVirtualSwitchId=null;evVirtualState=null;evVirtualName=null;return;}let desiredState=0;if(evEntry.state!==undefined){desiredState=parseInt(evEntry.state)? 1 : 0;}let desiredName=evEntry.name||("EV channel "+evVirtualChannelId);if(evVirtualSwitchId===null){try{let cfg={name: desiredName};evVirtualSwitchId=Shelly.addVirtualComponent("switch",cfg);evVirtualName=desiredName;(CONFIG.logLevel<=LOG.INFO)&&console.log("EV virtual switch created,id: "+evVirtualSwitchId+",name: "+desiredName);}catch(e){(CONFIG.logLevel<=LOG.ERROR)&&console.log("Error creating EV virtual switch: "+e);return;}}else if(desiredName&&evVirtualName!==desiredName){evVirtualName=desiredName;}if(evVirtualSwitchId!==null&&(evVirtualState===null||evVirtualState!==desiredState)){let onValue=desiredState===1 ? true : false;enqueueTask("shellycall","Switch.Set",{id: evVirtualSwitchId,on: onValue},function(){evVirtualState=desiredState;(CONFIG.logLevel<=LOG.INFO)&&console.log("EV virtual switch set to state: "+desiredState);});}}function DoFailsafeControls(){return;}function MainCycle(){(CONFIG.logLevel<=LOG.INFO)&&console.log("Cycle "+mainCycleCounter+"/"+cyclesUntilRequest+" until next request.");CheckRelayStates();CheckControlData();if((!isFailsafe)&&controlsData&&controlsReady){DoControls();}if(isFailsafe){DoFailsafeControls();}if(mainCycleCounter>=cyclesUntilRequest){controlsReady=false;RequestControldata();}mainCycleCounter++;}init()