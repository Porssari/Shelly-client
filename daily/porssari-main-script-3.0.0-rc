let VERSION = "Shelly-3.0.0-rc1";

// Settings
let CONFIG = {
    updatePeriod: 15000,
    apiEndpoint: "https://api.porssari.fi/getcontrols.php",
    registrationApiEndpoint: "https://api.porssari.fi/device_registration.php",
    returnTimestamps: 10,
    jsonVersion: 3,
    jsonChannelNames: false,
    logLevel: 0, // 0=debug, 1=info, 2=warn, 3=error
};

// Global variables
let shellyApp, shellyMac, shellyFwVer, scriptId, deviceChannels, storageType;
let currentUnixTime, jsonValidUntil, shellyUptime;
let lastRequest, lastRequestHttpCode;
let controlsData = virtualStatesReady = controlsInitialized = isTaskBusy = isTaskDelay = isFailsafe = false;
let mainCycleCounter = 20;
let cyclesUntilRequest = 20;
let mainTimer;

// Global dictionaries
let channelLastControlTimeStamps = [];
let relayStates = [];
let taskQueue = [];
let scheduleCache = null;
let channelDataCache = null;

// Virtuaaliaikaa varten (offline-toiminta uptimeen perustuen)
let virtualTime = 0;
let timeIsTrusted = false;
let lastUptime = null;
let lastVirtualTimeSave = 0;

// EV-latausaseman virtuaalikomponenttia varten
let evVirtualChannelId = 201;
let evVirtualSwitchId = null;
let evVirtualState = null;
let evVirtualName = null;

// Pörssäri-rekisteröintiä varten
let estateId = null;
let porssariRegistrationChecked = false;
let porssariRegistrationPending = false;
let porssariRegistrationComplete = false;
let porssariCredentialsComponentsCreated = false;
let estateIdEventHandler = null;
let estateIdRequestHandler = null;
let porssariUsernameHandle = null;
let porssariSecretHandle = null;
let porssariCredentialsStatusHandler = null;

// Logger
const LOG = {
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3
};

// Program init functions
function init() {
    (CONFIG.logLevel <= LOG.ERROR) && console.log("Pörssäri Control Script, version: " + VERSION);
    try {
        (CONFIG.logLevel <= LOG.INFO) && console.log("Retrieving device information...");
        enqueueTask('shellycall', 'Shelly.GetDeviceInfo', {}, InitCallback);
    } catch (e) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("An error occurred while retrieving device information. Stopping script. " + e);
        return;
    }
}

function InitCallback(result) {
    shellyApp = result.app;
    shellyMac = result.mac;
    shellyFwVer = result.ver;
    result = null;
    scriptId = (parseFloat(shellyFwVer) >= 1.5) ? Script.id : Shelly.getCurrentScriptId();
    
    if (shellyMac.length > 0) {
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("Device info: device " + shellyApp + ", id " + shellyMac + ", firmware version " + shellyFwVer + ", script-id " + scriptId);
    } else {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Could not get valid device information. Stopping script.");
        return;
    }

    storageType = parseFloat(shellyFwVer) >= 1.5 ? "ScriptStorage" : "None";

    // Käynnistetään Pörssäri-rekisteröinnin tarkistus
    // Ohjaustimer ja localstoragen lataus käynnistetään vasta rekisteröinnin onnistuttua
    InitPorssariRegistration();
    
    // Ohjausdatan pollaus aloitetaan vasta kun estateId on saatavilla (joko rekisteröintirajapinnasta tai LAN-eventistä)
    // Ei kutsuta RequestControldata() tässä vaiheessa
}

// Käynnistetään ohjausjärjestelmä rekisteröinnin onnistuttua
function StartControlSystem() {
    // Estetään useamman kerran käynnistys
    if (porssariRegistrationComplete) {
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("Control system already started, skipping.");
        return;
    }

    if (!estateId) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Cannot start control system: estateId not available.");
        return;
    }

    porssariRegistrationComplete = true;
    (CONFIG.logLevel <= LOG.INFO) && console.log("Pörssäri: registration complete, starting control system.");

    // Käynnistetään ohjaustimer
    mainTimer = Timer.set(CONFIG.updatePeriod, true, MainCycle);
    if (!mainTimer) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Main timer not initialized. Stopping script.");
        return;
    } else {
        (CONFIG.logLevel <= LOG.INFO) && console.log("Program loop timer initialized");
    }

    // Ladataan ohjaustiedot localstoragesta
    (CONFIG.logLevel <= LOG.DEBUG) && console.log("Loading controls data from storage...");
    LoadSavedControldata();
}

// Local data functions
function LoadSavedControldata() {
    (CONFIG.logLevel <= LOG.INFO) && console.log("Checking for existing data in local storage...");
    try {
        GetStorageValue('metadata', LoadSavedControldataCallback);
    } catch(e) {
        (CONFIG.logLevel <= LOG.INFO) && console.log("Saved data not found in local storage: " + e);
    }
}

function LoadSavedControldataCallback(result) {
    if (!result) {
        (CONFIG.logLevel <= LOG.INFO) && console.log("Saved control data not found from local storage.");
        // Jos rekisteröinti on valmis mutta dataa ei löydy, aloitetaan pollaus
        if (porssariRegistrationComplete && estateId) {
            (CONFIG.logLevel <= LOG.INFO) && console.log("Registration complete, starting control data polling.");
            controlsReady = false;
            RequestControldata();
        }
        return;
    }
    
    let data;
    try {
        data = JSON.parse(result);
        result = null;
        
        if (!data || typeof data !== "object") {
            (CONFIG.logLevel <= LOG.ERROR) && console.log("Invalid JSON structure in saved data.");
            return;
        }        

        deviceChannels = data.channels;
        lastRequest = data.timestamp;
        jsonValidUntil = data.valid_until;
        data = null;
        (CONFIG.logLevel <= LOG.INFO) && console.log("Found controls data from local storage.");
        controlsData = true;
        controlsReady = true;
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("Controlled channels: " + deviceChannels + ", valid until: " + jsonValidUntil + ", api endpoint: " + CONFIG.apiEndpoint);

        // Yritetään ladata virtuaaliaika ScriptStoragesta, jos se on talletettu aiemmin
        LoadVirtualTimeFromStorage();

        // Jos rekisteröinti on valmis, aloitetaan ohjausdatan pollaus
        if (porssariRegistrationComplete && estateId) {
            (CONFIG.logLevel <= LOG.INFO) && console.log("Registration complete, starting control data polling.");
            controlsReady = false;
            RequestControldata();
        }
    } catch (e) {
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("Saved control data not found from local storage: " + e);
        // Jos rekisteröinti on valmis mutta dataa ei löydy, aloitetaan pollaus
        if (porssariRegistrationComplete && estateId) {
            (CONFIG.logLevel <= LOG.INFO) && console.log("Registration complete, starting control data polling.");
            controlsReady = false;
            RequestControldata();
        }
    }
}

function SetStorageValue(baseKey, value) {

    if (storageType !== "ScriptStorage") {
        (CONFIG.logLevel <= LOG.INFO) && console.log("Local storage not supported for this firmware, skipping save for key " + baseKey);
        return;
    }

    let chunkSize = 1000;

    (CONFIG.logLevel <= LOG.DEBUG) && console.log("Saving data " + baseKey + " to " + storageType + " with chunk size: " + chunkSize);

    if (!value) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Error while saving data to local storage: Value not given");
        return;
    }

    value = btoa(JSON.stringify(value));
    let parts = Math.ceil(value.length / chunkSize);
    let chunks = [];

    for (let i = 0; i < parts; i++) {
        let chunk = value.substring(i * chunkSize, (i + 1) * chunkSize);
        let key = baseKey + "_" + i;
        chunks[key] = chunk;
        chunk = null;
    }
    value = null;

    try {
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("Check for previous chunks count for key " + baseKey);
        
        let previousParts = 0;

        for (let i = 0; i < Script.storage.length; i++) {
            const key = Script.storage.key(i);
            if (key.indexOf(baseKey) === 0) {
                previousParts += 1;
            }
        }
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("Found " + previousParts + " chunks from ScriptStorage for key " + baseKey);
        SetStorageValueCallback(baseKey, chunks, parts, previousParts);
    } catch (e) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Error retrieving previous chunks for key " + baseKey + ": " + e);
        SetStorageValueCallback(baseKey, chunks, parts, 0);
    }
}

function SetStorageValueCallback(baseKey, chunks, parts, previousParts) {
    if (storageType !== "ScriptStorage") {
        (CONFIG.logLevel <= LOG.INFO) && console.log("Local storage not supported for this firmware, skipping save for key " + baseKey);
        return;
    }

    for (let key in chunks) {
        Script.storage.setItem(key, chunks[key]);
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("Saved to ScriptStorage: " + key);
        chunks[key] = null;
    }
    chunks = null;

    if (previousParts > parts) {
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("Removing " + (previousParts - parts) + " old chunks.");
        for (let i = parts; i < previousParts; i++) {
            let key = baseKey + "_" + i;
            Script.storage.removeItem(key);
            (CONFIG.logLevel <= LOG.DEBUG) && console.log("Removed chunk: " + key + " from ScriptStorage");
        }
    }
}

function GetStorageValue(baseKey, callback) {
    if (storageType !== "ScriptStorage") {
        (CONFIG.logLevel <= LOG.INFO) && console.log("Local storage not supported for this firmware, returning no data for key " + baseKey);
        callback(null);
        return;
    }

    let parts = 0;

    for (let i = 0; i < Script.storage.length; i++) {
        const key = Script.storage.key(i);
        if (key.indexOf(baseKey) === 0) {
            parts += 1;
        }
    }

    let fullValue = "";

    for (let i = 0; i < parts; i++) {
        let keyToFind = baseKey + "_" + i;
        for (let j = 0; j < Script.storage.length; j++) {
            const key = Script.storage.key(j);
            if (key === keyToFind) {
                fullValue += Script.storage.getItem(key);
                break;           
            }
        }
    }

    callback(atob(fullValue));
    callback = null;
    fullValue = null;    
}

// Pörssäri-rekisteröintilogiikka
function InitPorssariRegistration() {
    if (porssariRegistrationChecked) {
        return;
    }

    porssariRegistrationChecked = true;

    // Jos rekisteröintirajapintaa ei ole määritelty, ei tehdä mitään
    if (!CONFIG.registrationApiEndpoint || CONFIG.registrationApiEndpoint.length === 0) {
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("Pörssäri registration endpoint not configured, skipping registration check.");
        return;
    }

    // Tarkistetaan löytyykö laite Pörssäri-palvelusta
    CheckDeviceRegistrationInPorssari();
}

function CheckDeviceRegistrationInPorssari() {
    try {
        let urlToCall = CONFIG.registrationApiEndpoint;

        (CONFIG.logLevel <= LOG.INFO) && console.log("Checking Pörssäri registration status...");
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("Registration URL: " + urlToCall);

        // Lähetetään POST-pyyntö, jossa on deviceId ja Shellyn perustiedot
        let postBody = JSON.stringify({
            deviceId: shellyMac,
            model: shellyApp,
            firmwareVersion: shellyFwVer,
            scriptVersion: VERSION
        });

        enqueueTask("shellycall", "HTTP.POST", { 
            "url": urlToCall, 
            "timeout": 10, 
            "ssl_ca": "*",
            "headers": { "Content-Type": "application/json" },
            "body": postBody
        }, CheckDeviceRegistrationInPorssariCallback);
    } catch (e) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Error while checking Pörssäri registration status: " + e);
    }
}

function CheckDeviceRegistrationInPorssariCallback(res, errCode, errMsg) {
    if (errCode !== 0 || !res) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Pörssäri registration check failed: " + errCode + " / " + errMsg);
        return;
    }

    try {
        if (res.code !== 200) {
            (CONFIG.logLevel <= LOG.INFO) && console.log("Pörssäri registration status HTTP code: " + res.code);
            return;
        }

        let body = JSON.parse(res.body);
        res = null;

        // Odotettu muoto:
        // { found: 1, building_id: "ABC123" } tai { found: 0 }
        if (!body || typeof body !== "object") {
            (CONFIG.logLevel <= LOG.ERROR) && console.log("Invalid Pörssäri registration JSON.");
            return;
        }

        let found = body.found !== undefined ? parseInt(body.found) : 0;
        if (found === 1 && body.building_id) {
            estateId = "" + body.building_id;
            (CONFIG.logLevel <= LOG.INFO) && console.log("Pörssäri: device already registered to estateId " + estateId + ".");

            // Rekisteröidään vastaajaksi estateId-kyselyihin ja emittoidaan tieto kerran
            StartEstateIdResponder();
            EmitPorssariBuildingIdToLan();

            // Rekisteröinti onnistui, käynnistetään ohjausjärjestelmä
            StartControlSystem();
        } else {
            (CONFIG.logLevel <= LOG.INFO) && console.log("Pörssäri: device not registered, waiting for building id from LAN or user.");

            // Aloitetaan kuuntelemaan sisäverkosta kiinteistö-id:tä
            StartListeningPorssariBuildingIdFromLan();
        }
    } catch (e) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Error while parsing Pörssäri registration status: " + e);
    }
}

// HUOM: seuraavat LAN-funktiot ovat tällä hetkellä vain runkoja.
// Varsinainen LAN-broadcast / -kuuntelu pitää toteuttaa käytetyn tekniikan mukaan (esim. UDP, MQTT tms.).

function EmitPorssariBuildingIdToLan() {
    if (!estateId) {
        return;
    }

    if (typeof Shelly === "undefined" || typeof Shelly.emitEvent !== "function") {
        (CONFIG.logLevel <= LOG.WARN) && console.log("Pörssäri: Shelly.emitEvent not available, cannot emit estateId.");
        return;
    }

    (CONFIG.logLevel <= LOG.INFO) && console.log("Pörssäri: emitting estateId " + estateId + " via Shelly event.");

    // Lähetetään tapahtuma, jonka kaikki pysyvät RPC-kanavat voivat kuunnella.
    // Esimerkiksi toinen Shelly voi reitittää tämän edelleen tai keskitetty integraatio voi välittää tiedon.
    try {
        Shelly.emitEvent("porssari_estate_id", {
            estateId: estateId,
            device_mac: shellyMac
        });
    } catch (e) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Pörssäri: exception while emitting estateId event: " + e);
    }
}

function StartListeningPorssariBuildingIdFromLan() {
    (CONFIG.logLevel <= LOG.INFO) && console.log("Pörssäri: listening for estateId events via Shelly.addEventHandler().");

    if (estateId) {
        // Jos estateId on jo tiedossa, ei tarvitse kuunnella
        return;
    }

    if (typeof Shelly === "undefined" || typeof Shelly.addEventHandler !== "function") {
        (CONFIG.logLevel <= LOG.WARN) && console.log("Pörssäri: Shelly.addEventHandler not available, cannot listen for estateId events.");
    } else {
        // Rekisteröidään event handler, joka reagoi porssari_estate_id -tapahtumiin
        estateIdEventHandler = Shelly.addEventHandler(function (ev, userdata) {
            try {
                if (!ev || !ev.event || ev.event !== "porssari_estate_id") {
                    return;
                }
                if (!ev.data || typeof ev.data.estateId === "undefined") {
                    return;
                }

                if (!estateId) {
                    OnPorssariBuildingIdReceived(ev.data.estateId);
                }
            } catch (e) {
                (CONFIG.logLevel <= LOG.ERROR) && console.log("Pörssäri: error in estateId event handler: " + e);
            }
        });

        // Lähetetään pyyntö estateId:n saamiseksi muilta laitteilta
        if (typeof Shelly.emitEvent === "function") {
            try {
                (CONFIG.logLevel <= LOG.INFO) && console.log("Pörssäri: emitting estateId request event.");
                Shelly.emitEvent("porssari_estate_id_request", {
                    device_mac: shellyMac
                });
            } catch (e) {
                (CONFIG.logLevel <= LOG.ERROR) && console.log("Pörssäri: error while emitting estateId request event: " + e);
            }
        }
    }

    // Jos estateId:tä ei saada tapahtumana 5 sekunnin kuluessa,
    // luodaan virtuaalikomponentit käyttäjätunnuksen ja salaisen avaimen syöttämistä varten.
    Timer.set(5000, false, function () {
        if (!estateId && !porssariCredentialsComponentsCreated) {
            CreatePorssariCredentialsVirtualComponents();
        }
    });
}

function OnPorssariBuildingIdReceived(buildingId) {
    if (!buildingId) {
        return;
    }

    estateId = "" + buildingId;
    (CONFIG.logLevel <= LOG.INFO) && console.log("Pörssäri: estateId received from LAN: " + estateId + ". Registering device for adoption.");

    // Poistetaan kuuntelu estateId:n saamiseksi, koska se on nyt saatavilla
    CleanupEstateIdListener();

    // Kun estateId on saatu, rekisteröidään vastaajaksi tuleviin pyyntöihin
    StartEstateIdResponder();

    RegisterDeviceForAdoptionInPorssari();

    // Rekisteröinti onnistui, käynnistetään ohjausjärjestelmä
    StartControlSystem();
}

// Laite, jolla on estateId, vastaa estateId-pyyntöihin
function StartEstateIdResponder() {
    if (!estateId) {
        return;
    }

    if (typeof Shelly === "undefined" || typeof Shelly.addEventHandler !== "function" || typeof Shelly.emitEvent !== "function") {
        (CONFIG.logLevel <= LOG.WARN) && console.log("Pörssäri: cannot start estateId responder, Shelly event API not available.");
        return;
    }

    if (estateIdRequestHandler) {
        // Jo rekisteröity
        return;
    }

    estateIdRequestHandler = Shelly.addEventHandler(function (ev, userdata) {
        try {
            if (!ev || !ev.event || ev.event !== "porssari_estate_id_request") {
                return;
            }

            // Ei vastata omaan pyyntöön (jos MAC sama)
            if (ev.data && ev.data.device_mac && ev.data.device_mac === shellyMac) {
                return;
            }

            // Vastataan estateId:llä
            (CONFIG.logLevel <= LOG.DEBUG) && console.log("Pörssäri: answering estateId request with estateId " + estateId + ".");
            EmitPorssariBuildingIdToLan();
        } catch (e) {
            (CONFIG.logLevel <= LOG.ERROR) && console.log("Pörssäri: error in estateId request handler: " + e);
        }
    });
}

function RegisterDeviceForAdoptionInPorssari() {
    if (!estateId) {
        (CONFIG.logLevel <= LOG.WARN) && console.log("Pörssäri: cannot register device for adoption, estateId missing.");
        return;
    }

    if (porssariRegistrationPending) {
        return;
    }
    porssariRegistrationPending = true;

    try {
        let urlToCall = CONFIG.registrationApiEndpoint;

        (CONFIG.logLevel <= LOG.INFO) && console.log("Pörssäri: registering device for adoption, estateId " + estateId + "...");
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("Pörssäri registration URL: " + urlToCall);

        // Lähetetään POST-pyyntö, jossa on deviceId, estateId ja Shellyn perustiedot
        let postBody = JSON.stringify({
            deviceId: shellyMac,
            estateId: estateId,
            model: shellyApp,
            firmwareVersion: shellyFwVer,
            scriptVersion: VERSION
        });

        enqueueTask("shellycall", "HTTP.POST", { 
            "url": urlToCall, 
            "timeout": 10, 
            "ssl_ca": "*",
            "headers": { "Content-Type": "application/json" },
            "body": postBody
        }, RegisterDeviceForAdoptionInPorssariCallback);
    } catch (e) {
        porssariRegistrationPending = false;
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Error while registering device for adoption in Pörssäri: " + e);
    }
}

function RegisterDeviceForAdoptionInPorssariCallback(res, errCode, errMsg) {
    porssariRegistrationPending = false;

    if (errCode !== 0 || !res) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Pörssäri adoption registration failed: " + errCode + " / " + errMsg);
        return;
    }

    try {
        (CONFIG.logLevel <= LOG.INFO) && console.log("Pörssäri adoption registration response code: " + res.code);
        
        // Jos rekisteröinti onnistui, poistetaan virtuaalikomponentit jos ne on luotu
        if (res.code === 200 && estateId) {
            CleanupPorssariCredentialsComponents();
        }
        // Myöhemmin tähän voidaan lisätä tarkempi JSON-tulkinta, kun rajapinta on olemassa
    } catch (e) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Error while handling Pörssäri adoption registration response: " + e);
    }
}

// Virtuaalikomponentit Pörssäri-käyttäjätunnusta ja salaista avainta varten
function CreatePorssariCredentialsVirtualComponents() {
    if (porssariCredentialsComponentsCreated) {
        return;
    }

    // Jos laite on jo liitetty kiinteistöön, ei tarvita cred-komponentteja
    if (estateId) {
        return;
    }

    if (typeof Virtual === "undefined" || typeof Virtual.Add !== "function" || typeof Virtual.getHandle !== "function") {
        (CONFIG.logLevel <= LOG.WARN) && console.log("Pörssäri: Virtual component API not available, cannot create credentials components.");
        return;
    }

    try {
        // Käytetään tekstityyppisiä virtuaalikomponentteja ID-alueelta 200–299
        //  - porssari_username: text:210
        //  - porssari_secret:   text:211

        let usernameResult = Virtual.Add({
            type: "text",
            config: { name: "porssari_username" },
            id: 210
        });

        let secretResult = Virtual.Add({
            type: "text",
            config: { name: "porssari_secret" },
            id: 211
        });

        (CONFIG.logLevel <= LOG.INFO) && console.log("Pörssäri: virtual components for username and secret created (text:210, text:211).");
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("Pörssäri: usernameResult=" + JSON.stringify(usernameResult) + ", secretResult=" + JSON.stringify(secretResult));

        // Haetaan handle:t virtuaalikomponenteille, jotta voidaan lukea niiden arvot
        try {
            porssariUsernameHandle = Virtual.getHandle("text:210");
            porssariSecretHandle = Virtual.getHandle("text:211");
        } catch (e) {
            (CONFIG.logLevel <= LOG.ERROR) && console.log("Pörssäri: error getting virtual component handles: " + e);
        }

        // Rekisteröidään status handler, joka kuuntelee virtuaalikomponenttien muutoksia
        StartListeningPorssariCredentialsChanges();

        porssariCredentialsComponentsCreated = true;
    } catch (e) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Pörssäri: error while creating credentials virtual components: " + e);
    }
}

// Kuunnellaan virtuaalikomponenttien muutoksia (käyttäjätunnus ja passcode)
function StartListeningPorssariCredentialsChanges() {
    if (porssariCredentialsStatusHandler) {
        // Jo rekisteröity
        return;
    }

    if (typeof Shelly === "undefined" || typeof Shelly.addStatusHandler !== "function") {
        (CONFIG.logLevel <= LOG.WARN) && console.log("Pörssäri: Shelly.addStatusHandler not available, cannot listen for credential changes.");
        return;
    }

    porssariCredentialsStatusHandler = Shelly.addStatusHandler(function (status, userdata) {
        try {
            // Tarkistetaan onko virtuaalikomponenttien tila muuttunut
            if (!status || !status.virtual || !status.virtual.text) {
                return;
            }

            // Tarkistetaan onko molemmat kentät täytetty
            let username = null;
            let passcode = null;

            if (status.virtual.text[210] && status.virtual.text[210].value) {
                username = status.virtual.text[210].value;
            }
            if (status.virtual.text[211] && status.virtual.text[211].value) {
                passcode = status.virtual.text[211].value;
            }

            // Jos molemmat kentät on täytetty ja laite ei ole vielä rekisteröity, lähetetään rekisteröintipyyntö
            if (username && passcode && !estateId && !porssariRegistrationPending) {
                (CONFIG.logLevel <= LOG.INFO) && console.log("Pörssäri: credentials filled, registering device with username and passcode.");
                RegisterDeviceWithCredentialsInPorssari(username, passcode);
            }
        } catch (e) {
            (CONFIG.logLevel <= LOG.ERROR) && console.log("Pörssäri: error in credentials status handler: " + e);
        }
    });
}

// Rekisteröidään laite käyttäjätunnuksen ja passcode:n avulla
function RegisterDeviceWithCredentialsInPorssari(username, passcode) {
    if (!username || !passcode) {
        (CONFIG.logLevel <= LOG.WARN) && console.log("Pörssäri: cannot register device, username or passcode missing.");
        return;
    }

    if (porssariRegistrationPending) {
        return;
    }
    porssariRegistrationPending = true;

    try {
        let urlToCall = CONFIG.registrationApiEndpoint;

        (CONFIG.logLevel <= LOG.INFO) && console.log("Pörssäri: registering device with credentials...");
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("Pörssäri registration URL: " + urlToCall);

        // Lähetetään POST-pyyntö, jossa on deviceId, username, passcode ja Shellyn perustiedot
        let postBody = JSON.stringify({
            deviceId: shellyMac,
            username: username,
            passcode: passcode,
            model: shellyApp,
            firmwareVersion: shellyFwVer,
            scriptVersion: VERSION
        });

        enqueueTask("shellycall", "HTTP.POST", { 
            "url": urlToCall, 
            "timeout": 10, 
            "ssl_ca": "*",
            "headers": { "Content-Type": "application/json" },
            "body": postBody
        }, RegisterDeviceWithCredentialsCallback);
    } catch (e) {
        porssariRegistrationPending = false;
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Error while registering device with credentials in Pörssäri: " + e);
    }
}

function RegisterDeviceWithCredentialsCallback(res, errCode, errMsg) {
    porssariRegistrationPending = false;

    if (errCode !== 0 || !res) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Pörssäri credentials registration failed: " + errCode + " / " + errMsg);
        return;
    }

    try {
        if (res.code === 200) {
            let body = JSON.parse(res.body);
            res = null;

            // Odotettu muoto: { estateId: "ABC123" } tai vastaava
            if (body && body.estateId) {
                estateId = "" + body.estateId;
                (CONFIG.logLevel <= LOG.INFO) && console.log("Pörssäri: device registered successfully, estateId: " + estateId + ".");

                // Poistetaan turhat listenerit ja virtuaalikomponentit, koska rekisteröinti onnistui
                CleanupEstateIdListener();
                CleanupPorssariCredentialsComponents();

                // Rekisteröidään vastaajaksi estateId-kyselyihin
                StartEstateIdResponder();
                EmitPorssariBuildingIdToLan();

                // Rekisteröinti onnistui, käynnistetään ohjausjärjestelmä
                StartControlSystem();
            } else {
                (CONFIG.logLevel <= LOG.INFO) && console.log("Pörssäri credentials registration response code: " + res.code);
            }
        } else {
            (CONFIG.logLevel <= LOG.INFO) && console.log("Pörssäri credentials registration response code: " + res.code);
        }
    } catch (e) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Error while handling Pörssäri credentials registration response: " + e);
    }
}

// Poistetaan estateId:n kuuntelu, koska se on nyt saatavilla
function CleanupEstateIdListener() {
    if (estateIdEventHandler && typeof Shelly !== "undefined" && typeof Shelly.removeEventHandler === "function") {
        try {
            Shelly.removeEventHandler(estateIdEventHandler);
            estateIdEventHandler = null;
            (CONFIG.logLevel <= LOG.DEBUG) && console.log("Pörssäri: estateId event listener removed.");
        } catch (e) {
            (CONFIG.logLevel <= LOG.ERROR) && console.log("Pörssäri: error removing estateId event listener: " + e);
        }
    }
}

// Poistetaan virtuaalikomponentit ja credentials status handler, koska rekisteröinti onnistui
function CleanupPorssariCredentialsComponents() {
    // Poistetaan credentials status handler
    if (porssariCredentialsStatusHandler && typeof Shelly !== "undefined" && typeof Shelly.removeStatusHandler === "function") {
        try {
            Shelly.removeStatusHandler(porssariCredentialsStatusHandler);
            porssariCredentialsStatusHandler = null;
            (CONFIG.logLevel <= LOG.DEBUG) && console.log("Pörssäri: credentials status handler removed.");
        } catch (e) {
            (CONFIG.logLevel <= LOG.ERROR) && console.log("Pörssäri: error removing credentials status handler: " + e);
        }
    }

    // Poistetaan virtuaalikomponentit jos ne on luotu
    if (porssariCredentialsComponentsCreated && typeof Shelly !== "undefined" && typeof Shelly.removeComponent === "function") {
        try {
            // Poistetaan username-komponentti (text:210)
            Shelly.removeComponent("text:210");
            (CONFIG.logLevel <= LOG.INFO) && console.log("Pörssäri: virtual component text:210 (username) removed.");
        } catch (e) {
            (CONFIG.logLevel <= LOG.DEBUG) && console.log("Pörssäri: error removing username component (may not exist): " + e);
        }

        try {
            // Poistetaan secret-komponentti (text:211)
            Shelly.removeComponent("text:211");
            (CONFIG.logLevel <= LOG.INFO) && console.log("Pörssäri: virtual component text:211 (secret) removed.");
        } catch (e) {
            (CONFIG.logLevel <= LOG.DEBUG) && console.log("Pörssäri: error removing secret component (may not exist): " + e);
        }

        porssariCredentialsComponentsCreated = false;
        porssariUsernameHandle = null;
        porssariSecretHandle = null;
    }
}

// Virtuaaliajan tallennus ja lataus ScriptStoragesta
function SaveVirtualTimeToStorage() {
    if (storageType !== "ScriptStorage") {
        return;
    }

    if (!timeIsTrusted || !virtualTime || virtualTime <= 0) {
        return;
    }

    let payload = {
        virtual_time: virtualTime
    };

    if (jsonValidUntil) {
        payload.json_valid_until = jsonValidUntil;
    }
    if (lastRequest) {
        payload.last_request = lastRequest;
    }

    try {
        SetStorageValue('virtualtime', payload);
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("Virtual time saved to storage: " + virtualTime);
    } catch (e) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Error while saving virtual time to storage: " + e);
    }
}

function LoadVirtualTimeFromStorage() {
    if (storageType !== "ScriptStorage") {
        return;
    }

    try {
        GetStorageValue('virtualtime', function (result) {
            if (!result) {
                (CONFIG.logLevel <= LOG.DEBUG) && console.log("No virtual time found in storage.");
                return;
            }

            try {
                let data = JSON.parse(result);
                result = null;

                if (data && typeof data === "object" && data.virtual_time !== undefined) {
                    let vt = parseInt(data.virtual_time);
                    if (!isNaN(vt) && vt > 0) {
                        virtualTime = vt;
                        timeIsTrusted = true;
                        lastVirtualTimeSave = virtualTime;
                        currentUnixTime = virtualTime;
                        (CONFIG.logLevel <= LOG.INFO) && console.log("Virtual time loaded from storage: " + virtualTime);
                    }
                }
            } catch (e) {
                (CONFIG.logLevel <= LOG.ERROR) && console.log("Error parsing virtual time from storage: " + e);
            }
        });
    } catch (e) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Error while loading virtual time from storage: " + e);
    }
}

// Päivitetään virtuaaliaika Shellyn uptimen perusteella
function UpdateVirtualTime() {
    let uptime = null;

    try {
        if (typeof Shelly !== "undefined" && typeof Shelly.getComponentStatus === "function") {
            // Gen2-laitteet: uptime saatavilla sys-komponentista
            let sys = Shelly.getComponentStatus("sys", 0);
            if (sys && typeof sys.uptime !== "undefined") {
                uptime = parseInt(sys.uptime);
            }
        }
    } catch (e) {
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("Error while reading system uptime: " + e);
    }

    // Jos uptimen lukeminen ei onnistu, käytetään vararatkaisuna Date.now()-pohjaista aikaleimaa
    if (uptime === null || isNaN(uptime) || uptime < 0) {
        if (!timeIsTrusted || virtualTime <= 0) {
            virtualTime = Math.floor(Date.now() / 1000);
            timeIsTrusted = true;
            currentUnixTime = virtualTime;
        }
        return;
    }

    if (lastUptime === null) {
        // Ensimmäinen kerta tällä ajolla
        lastUptime = uptime;
        if (!timeIsTrusted || virtualTime <= 0) {
            virtualTime = Math.floor(Date.now() / 1000);
            timeIsTrusted = true;
        }
        currentUnixTime = virtualTime;
        return;
    }

    let delta = uptime - lastUptime;
    if (delta <= 0) {
        lastUptime = uptime;
        currentUnixTime = virtualTime;
        return;
    }

    virtualTime += delta;
    lastUptime = uptime;
    currentUnixTime = virtualTime;
}

// Virtuaaliajan säännöllinen tallennus
function MaybeSaveVirtualTime() {
    if (!timeIsTrusted || !virtualTime || virtualTime <= 0) {
        return;
    }

    // Tallennetaan korkeintaan noin kerran minuutissa
    if (lastVirtualTimeSave === 0 || (virtualTime - lastVirtualTimeSave) >= 60) {
        SaveVirtualTimeToStorage();
        lastVirtualTimeSave = virtualTime;
    }
}

// Server request
function RequestControldata() {
    // Vain rekisteröidyt laitteet (joilla on estateId) saavat ohjausdataa
    if (!estateId) {
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("Skipping control data request: device not registered (no estateId).");
        controlsReady = true;
        cyclesUntilRequest = 18 + Math.floor(3 * Math.random());
        mainCycleCounter = 1;
        return;
    }

    try {
        (CONFIG.logLevel <= LOG.INFO) && console.log("Requesting control data from server...");
        let urlToCall = CONFIG.apiEndpoint + "?device_mac=" + shellyMac + "&last_request=" + (lastRequest || 0) + "&script_version=" + VERSION + "&client_model=" + shellyApp + "&client_fw=" + shellyFwVer + "&cut_schedule=" + CONFIG.returnTimestamps + "&json_version=" + CONFIG.jsonVersion + "&json_channel_names=" + CONFIG.jsonChannelNames;
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("URL: " + urlToCall);
        enqueueTask("shellycall", "HTTP.GET", { "url": urlToCall, "timeout": 10, "ssl_ca": "*" }, RequestControldataCallback);
        urlToCall = null;
    } catch (e) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Error while requesting control data from server: " + e);
        controlsReady = true;
        cyclesUntilRequest = 18 + Math.floor(3 * Math.random());
        mainCycleCounter = 1;
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("Resetting request cycle counter. Cycles before next request: " + cyclesUntilRequest);
    }
}

function RequestControldataCallback(res, errCode, errMsg) {
    let requestInfo;
    
    if (errCode != 0) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Request error: " + errCode, errMsg);
        return;
    }
    
    if (!res) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Invalid response: " + errCode, errMsg);
        return;
    }

    try {
        if (res.code === 200) {
            requestInfo = 'Get controls successful. Code 200.';

            let parsedBody = JSON.parse(res.body);
            res = null; 
            
            let metadata = parsedBody.metadata;
            // json_version=3: controls = [[timestamp, channel, state], ...]
            // channel_states = [{ id, name, updated, state }, ...]
            let schedule = parsedBody.controls;
            let channelData = parsedBody.channel_states;
            parsedBody = null;

            SetStorageValue('metadata', metadata);
            deviceChannels = parseInt(metadata.channels);
            CONFIG.apiEndpoint = metadata.fetch_url;
            lastRequest = parseInt(metadata.timestamp);
            jsonValidUntil = parseInt(metadata.valid_until);
            metadata = null;        

            // Päivitetään virtuaaliaika nykyiseen aikaan, koska NTP-aika on juuri varmennettu serveriltä
            virtualTime = Math.floor(Date.now() / 1000);
            timeIsTrusted = true;
            currentUnixTime = virtualTime;
        
            if (schedule && Array.isArray(schedule)) {
                // Lajitellaan aikaleiman mukaan (vanhimmasta uusimpaan) ilman Array.sortia
                schedule = sortFlatScheduleByTimestamp(schedule);
                if (storageType === "ScriptStorage") {
                    SetStorageValue('schedule', schedule);
                    scheduleCache = null;
                    (CONFIG.logLevel <= LOG.DEBUG) && console.log("Schedule stored to ScriptStorage, entries: " + schedule.length);
                } else {
                    scheduleCache = schedule;
                    (CONFIG.logLevel <= LOG.DEBUG) && console.log("Schedule cached in memory, entries: " + scheduleCache.length);
                }
            } else {
                if (storageType !== "ScriptStorage") {
                    scheduleCache = null;
                }
                (CONFIG.logLevel <= LOG.DEBUG) && console.log("No schedule object found in JSON response.");
            }
            schedule = null;

            if (channelData && typeof channelData === "object") {
                // Muutetaan channel_states taulukko mapiksi, jossa key = (id-1)
                let mappedChannelData = {};
                for (let i = 0; i < channelData.length; i++) {
                    let chEntry = channelData[i];
                    if (!chEntry || chEntry.id === undefined) continue;

                    let chId = parseInt(chEntry.id);
                    if (isNaN(chId) || chId <= 0) continue;

                    let switchId = chId - 1;
                    mappedChannelData[switchId] = {
                        state: chEntry.state !== undefined ? parseInt(chEntry.state) : 0,
                        updated: chEntry.updated !== undefined ? parseInt(chEntry.updated) : 0,
                        name: chEntry.name || ""
                    };
                }

                channelDataCache = mappedChannelData;
                (CONFIG.logLevel <= LOG.DEBUG) && console.log("Channel data cache loaded.");
            } else {
                channelDataCache = null;
                (CONFIG.logLevel <= LOG.DEBUG) && console.log("No channel_data object found in JSON response.");
            }

            // Päivitetään sähköauton latausasemaa varten virtuaalinen switch-kanava (201)
            HandleEvVirtualComponent(channelData);
            channelData = null;

            // Talletetaan virtuaaliaika ScriptStorageen, jotta se voidaan palauttaa offline-tilanteessa
            SaveVirtualTimeToStorage();

            controlsData = true;

            (CONFIG.logLevel <= LOG.DEBUG) && console.log("Controls JSON parsed.");
            (CONFIG.logLevel <= LOG.DEBUG) && console.log("Controlled channels: " + deviceChannels + ", valid until: " + jsonValidUntil + ", api endpoint: " + CONFIG.apiEndpoint);
        } else if (res.code === 204) {
            requestInfo = "Device found from server without associated loads: " + res.code;
            res = null;
        } else if (res.code === 304) {
            requestInfo = "Controls data not updated after last request: " + res.code;
            res = null;

            // 304 vastauksen yhteydessä voidaan luottaa siihen, että laite on onlinessa ja NTP-aika kunnossa,
            // joten sidotaan virtuaaliaika nykyiseen kellonaikaan.
            virtualTime = Math.floor(Date.now() / 1000);
            timeIsTrusted = true;
            currentUnixTime = virtualTime;

            // Talletetaan ajantasainen virtuaaliaika ScriptStorageen
            SaveVirtualTimeToStorage();
        } else {
            requestInfo = "Invalid server request. Code: " + res.code;
            res = null;
        }
    } catch (e) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Control data request failed: " + e)
    }
     
    (CONFIG.logLevel <= LOG.INFO) && console.log("Server request done. " + requestInfo);
    requestInfo = null;
    controlsReady = true;

    cyclesUntilRequest = 18 + Math.floor(3 * Math.random());
    mainCycleCounter = 1;
    (CONFIG.logLevel <= LOG.DEBUG) && console.log("Resetting request cycle counter. Cycles before next request: " + cyclesUntilRequest);
}

// Control data functions
function CheckControlData() {
    (CONFIG.logLevel <= LOG.DEBUG) && console.log("Checking if control data is valid."); 
    isFailsafe = false;

    if (controlsData && jsonValidUntil <= currentUnixTime) {      
        (CONFIG.logLevel <= LOG.INFO) && console.log("The control schedule is empty. Activating failsafe mode.");
        isFailsafe = true;            
    }

    if (!controlsData) {
        (CONFIG.logLevel <= LOG.INFO) && console.log("Control data not available. Activating failsafe mode.");
        isFailsafe = true;
    }

    if (isFailsafe) {
        if (mainCycleCounter > cyclesUntilRequest) {
            cyclesUntilRequest = 18 + Math.floor(3 * Math.random());
            mainCycleCounter = 1;
            (CONFIG.logLevel <= LOG.DEBUG) && console.log("Resetting request cycle counter. Cycles before next request: " + cyclesUntilRequest);
        }
        return;    
    }

    (CONFIG.logLevel <= LOG.INFO) && console.log("Control data is valid for " + parseInt((jsonValidUntil - currentUnixTime) / 60) + " minutes");
}

function DoControls() {
    (CONFIG.logLevel <= LOG.INFO) && console.log("Updating virtual states for relays...");
    virtualStatesReady = false;
    // Luetaan aikataulu ScriptStoragesta, jos saatavilla. Jos ei, käytetään muistissa olevaa scheduleCachea.
    if (storageType === "ScriptStorage") {
        GetStorageValue('schedule', DoControlsCallback);
    } else {
        DoControlsCallback(null);
    }
}

function DoControlsCallback(value) {
    let schedule = null;

    // Valitaan aikataulu:
    // - jos ScriptStorage käytössä: luetaan yksinomaan ScriptStoragesta (value)
    // - jos ScriptStorage ei käytössä: käytetään vain muistissa olevaa scheduleCachea
    try {
        if (storageType === "ScriptStorage") {
            if (value) {
                schedule = JSON.parse(value);
                value = null;
            }
        } else {
            if (scheduleCache && Array.isArray(scheduleCache)) {
                schedule = scheduleCache;
            }
        }
    } catch (e) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Error parsing schedule JSON: " + e);
        virtualStatesReady = true;
        return;
    }

    if (!schedule || !Array.isArray(schedule) || schedule.length === 0) {
        (CONFIG.logLevel <= LOG.INFO) && console.log("No valid schedule found, virtual states not updated.");
        schedule = null;
        virtualStatesReady = true;
        return;
    }

    (CONFIG.logLevel <= LOG.DEBUG) && console.log("Found schedule data, updating virtual states...");

    // Initialize Shelly to current state using flat schedule [timestamp, channel, state]
    if (!controlsInitialized) {
        (CONFIG.logLevel <= LOG.INFO) && console.log("Script has started, initializing virtual states...");
        try {
            // Esilasketaan per-kanava lähtötila channelDataCachen ja lastRequestin perusteella
            let baseState = [];
            let baseTimestamp = [];

            for (let ch = 1; ch <= deviceChannels; ch++) {
                let switchId = ch - 1;
                baseState[switchId] = 0;
                baseTimestamp[switchId] = lastRequest || 0;

                if (channelDataCache && channelDataCache[switchId]) {
                    if (channelDataCache[switchId].state !== undefined) {
                        baseState[switchId] = parseInt(channelDataCache[switchId].state);
                    }
                    if (channelDataCache[switchId].updated !== undefined) {
                        let updTs = parseInt(channelDataCache[switchId].updated);
                        if (!isNaN(updTs) && updTs > baseTimestamp[switchId]) {
                            baseTimestamp[switchId] = updTs;
                        }
                    }
                }

                (CONFIG.logLevel <= LOG.DEBUG) && console.log("Relay " + ch + ": initializing, base state from channel_data: " + baseState[switchId] + ", base ts: " + baseTimestamp[switchId]);
            }

            // Yksi globaali läpijuoksu: päivitetään jokaisen kanavan tila viimeisimmän menneen timestampin mukaan
            for (let i = 0; i < schedule.length; i++) {
                let row = schedule[i];
                let ts = parseInt(row[0]);
                if (isNaN(ts) || ts >= currentUnixTime) {
                    continue;
                }

                let ch = parseInt(row[1]);
                let state = parseInt(row[2]);
                if (isNaN(ch) || ch <= 0) {
                    continue;
                }

                let switchId = ch - 1;
                if (ts >= baseTimestamp[switchId]) {
                    baseState[switchId] = state;
                    baseTimestamp[switchId] = ts;
                    (CONFIG.logLevel <= LOG.DEBUG) && console.log("Relay " + ch + ": passed timestamp: " + ts + ", state: " + state);
                }
            }

            // Päivitetään virtuaalitilat yhden kerran per kanava
            for (let ch = 1; ch <= deviceChannels; ch++) {
                let switchId = ch - 1;
                updateVirtualState(switchId, baseState[switchId]);
                channelLastControlTimeStamps[switchId] = baseTimestamp[switchId];
            }

            controlsInitialized = true;
            schedule = null;
            virtualStatesReady = true;
            (CONFIG.logLevel <= LOG.INFO) && console.log("Virtual states initialized.");
            return;
        } catch (e) {
            controlsInitialized = false;
            schedule = null;
            virtualStatesReady = true;
            (CONFIG.logLevel <= LOG.ERROR) && console.log("Error while initializing virtual states from schedule: " + e);
            return;
        }
    }
    
    // Jos jo alustettu, luetaan joko channel_data.updated tai schedule globaalilla läpijuoksulla
    (CONFIG.logLevel <= LOG.INFO) && console.log("Reading schedule or updated state from channel_data...");
	try {
        let lastTsPerChannel = [];
        let newTsPerChannel = [];
        let newStatePerChannel = [];
        let useChannelDataOverride = [];

        // Esilue kanavakohtaiset viimeiset ohjaustimestampit ja mahdolliset channel_data-päivitykset
        for (let ch = 1; ch <= deviceChannels; ch++) {
            let switchId = ch - 1;
            let lastTs = parseInt(channelLastControlTimeStamps[switchId] || 0);
            lastTsPerChannel[switchId] = lastTs;
            newTsPerChannel[switchId] = lastTs;
            newStatePerChannel[switchId] = null;
            useChannelDataOverride[switchId] = false;

            let updatedTs = 0;
            let currentStateFromChannelData = null;

            if (channelDataCache && channelDataCache[switchId]) {
                if (channelDataCache[switchId].updated !== undefined) {
                    updatedTs = parseInt(channelDataCache[switchId].updated);
                }
                if (channelDataCache[switchId].state !== undefined) {
                    currentStateFromChannelData = parseInt(channelDataCache[switchId].state);
                }
            }

            (CONFIG.logLevel <= LOG.DEBUG) && console.log("Relay " + ch + ": channel_data updated: " + updatedTs + ", last controlled timestamp: " + lastTs);

            if (updatedTs > lastTs && currentStateFromChannelData !== null) {
                // Kanavan asetuksia / tilaa päivitetty JSONissa viime ohjauksen jälkeen -> siirrytään suoraan sen tilaan
                useChannelDataOverride[switchId] = true;
                newStatePerChannel[switchId] = currentStateFromChannelData;
                newTsPerChannel[switchId] = currentUnixTime;
                (CONFIG.logLevel <= LOG.DEBUG) && console.log("Relay " + ch + ": will switch directly to channel_data state " + currentStateFromChannelData + " at ts " + currentUnixTime);
            }
        }

        // Käydään koko schedule kerran läpi ja etsitään mahdolliset uudet ohjaukset kanaville, joille EI ole channel_data-overridea
        for (let i = 0; i < schedule.length; i++) {
            let row = schedule[i];
            let ts = parseInt(row[0]);
            if (isNaN(ts) || ts > currentUnixTime) {
                continue;
            }

            let ch = parseInt(row[1]);
            let state = parseInt(row[2]);
            if (isNaN(ch) || ch <= 0) {
                continue;
            }

            let switchId = ch - 1;
            if (useChannelDataOverride[switchId]) {
                continue;
            }

            let lastTs = lastTsPerChannel[switchId];
            if (ts > lastTs && ts >= newTsPerChannel[switchId]) {
                newTsPerChannel[switchId] = ts;
                newStatePerChannel[switchId] = state;
                (CONFIG.logLevel <= LOG.DEBUG) && console.log("Relay " + ch + ": candidate passed timestamp: " + ts + ", state: " + state);
            }
        }

        // Päivitä virtuaalitilat niille kanaville, joille löytyi uusi tila (channel_data override tai schedule)
        for (let ch = 1; ch <= deviceChannels; ch++) {
            let switchId = ch - 1;
            let newTs = newTsPerChannel[switchId];
            let lastTs = lastTsPerChannel[switchId];
            let state = newStatePerChannel[switchId];

            if (state !== null && newTs > lastTs) {
                updateVirtualState(switchId, state);
                channelLastControlTimeStamps[switchId] = newTs;
                (CONFIG.logLevel <= LOG.DEBUG) && console.log("Relay " + ch + ": final control timestamp: " + newTs + ", state: " + state);
            } else {
                (CONFIG.logLevel <= LOG.DEBUG) && console.log("Relay " + ch + ": no new control actions needed.");
            }
        }

        (CONFIG.logLevel <= LOG.INFO) && console.log("Virtual states updated.");
    } catch (e) {
        (CONFIG.logLevel <= LOG.INFO) && console.log("Virtual states not updated due to unknown error while reading schedule: " + e);
    }
    // channelDataCachea tarvitaan vain ensimmäisen päivityssyklin jälkeen uuden JSON-haun jälkeen,
    // joten se voidaan nollata tämän funktion lopussa, jotta muistia vapautuu.
    channelDataCache = null;
    schedule = null;
    virtualStatesReady = true;
}

function updateVirtualState(switchId, state) {
    if (!relayStates[switchId]) {
        relayStates[switchId] = { id: null, virtualState: 0, realState: 0, inputState: 0, updated: false, checked: false };
    }

    relayStates[switchId].virtualState = state;
    relayStates[switchId].id = switchId;
    relayStates[switchId].updated = true;
    relayStates[switchId].checked = false;

    (CONFIG.logLevel <= LOG.DEBUG) && console.log("Updated virtualState for switch " + switchId +": new virtual state: " + relayStates[switchId].virtualState);
}

function CheckRelayStates() {

    if (!relayStates) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Could not find any controlled relays.");
        return;
    }

    let relayKeys = Object.keys(relayStates);

    if (!relayKeys || relayKeys.length == 0) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Could not find any controlled relays.");
        return;
    }
    (CONFIG.logLevel <= LOG.INFO) && console.log("Checking relay states...");

    for (let relayEntry in relayKeys) {
        let switchId = relayStates[relayEntry].id;
        enqueueTask("shellycall", "Switch.GetStatus", { id: switchId }, CheckRelayStatesCallback);
    }
}

function CheckRelayStatesCallback(res, errCode, errMsg) {

    if (errCode !== 0 || !res) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Error with switch data." + errMsg);
        return;
    }
    
    try {
        let switchId = parseInt(res.id);

        // Päivitetään releen todellinen tila Shellyn raportin perusteella
        relayStates[switchId].realState = res.output ? 1 : 0;

        // Luetaan mahdollisen ulkoisen kytkimen (input) tila, jos saatavilla
        // 1 = kytkin päällä, 0 = kytkin pois päältä
        let inputState = 0;
        if (typeof res.input !== "undefined") {
            inputState = res.input ? 1 : 0;
        }

        if (!relayStates[switchId]) {
            relayStates[switchId] = { id: switchId, virtualState: 0, realState: 0, inputState: inputState, updated: false, checked: false };
        } else {
            relayStates[switchId].inputState = inputState;
        }

        res = null;
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("Updated state information for switch " + switchId +": virtual state: " + relayStates[switchId].virtualState + ", real state: " + relayStates[switchId].realState + ", updated: " + relayStates[switchId].updated + ", checked: " + relayStates[switchId].checked);

        if (relayStates[switchId].updated) {
            (CONFIG.logLevel <= LOG.DEBUG) && console.log("Virtual state updated for switch " + switchId + ", executing controls...");
            let state = relayStates[switchId].virtualState;

            // Estetään releen sammuttaminen, jos ulkoinen kytkin on päällä.
            // Toiseen suuntaan (releen kytkeminen päälle) muutos sallitaan aina.
            if (state === 0 && relayStates[switchId].inputState === 1) {
                let relay = switchId + 1;
                (CONFIG.logLevel <= LOG.DEBUG) && console.log("Relay " + relay + ": virtual OFF ignored because external switch is ON.");
                // Merkitään tila tarkistetuksi, jotta skripti ei yritä jatkuvasti uudelleen.
                relayStates[switchId].updated = false;
                relayStates[switchId].checked = true;
                return;
            }

            enqueueTask("shellycall", "Switch.Set", { "id": switchId, "on": state === 1 ? true : false }, function() {
                relayStates[switchId].updated = false;
                let relay = switchId + 1;
                (CONFIG.logLevel <= LOG.INFO) && console.log("Relay " + relay + ": switched to state: " + state);   
            });
            return;
        }

        if ((!relayStates[switchId].checked) && (relayStates[switchId].virtualState !== relayStates[switchId].realState)) {
            (CONFIG.logLevel <= LOG.DEBUG) && console.log("State not updated correctly for switch " + switchId + ", executing controls...");
            let state = relayStates[switchId].virtualState;

            // Estetään releen sammuttaminen, jos ulkoinen kytkin on päällä.
            if (state === 0 && relayStates[switchId].inputState === 1) {
                let relay = switchId + 1;
                (CONFIG.logLevel <= LOG.DEBUG) && console.log("Relay " + relay + ": virtual OFF ignored because external switch is ON.");
                relayStates[switchId].updated = false;
                relayStates[switchId].checked = true;
                return;
            }

            enqueueTask("shellycall", "Switch.Set", { "id": switchId, "on": state === 1 ? true : false }, function() {
                relayStates[switchId].updated = false;
                (CONFIG.logLevel <= LOG.INFO) && console.log("Switch " +  switchId + " set to state " +  state);   
            });
            return;
        } else if (!relayStates[switchId].checked) {
            let relay = switchId + 1;
            (CONFIG.logLevel <= LOG.INFO) && console.log("Relay " + relay + ": state checked after passed timestamp.");
            relayStates[switchId].checked = true;
        } else if ((relayStates[switchId].checked) && (relayStates[switchId].virtualState !== relayStates[switchId].realState)) {
            let relay = switchId + 1;
            (CONFIG.logLevel <= LOG.INFO) && console.log("Relay " + relay + ": relay state is switched by user.");
        } else if (relayStates[switchId].checked) {
            let relay = switchId + 1;
            (CONFIG.logLevel <= LOG.INFO) && console.log("Relay " + relay + ": relay state is up to date.");
        }
    } catch(e) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Error with switch data." + e);
    }
}

// Task queue
function enqueueTask(type, method, params, callback) {
    // Maksimikoko taskQueue:lle estää muistivuodot
    const MAX_TASK_QUEUE_SIZE = 50;
    
    if (taskQueue.length >= MAX_TASK_QUEUE_SIZE) {
        (CONFIG.logLevel <= LOG.WARN) && console.log("Task queue full (" + taskQueue.length + "), dropping oldest task.");
        taskQueue.shift(); // Poistetaan vanhin tehtävä
    }
    
    taskQueue.push({ type: type, method: method, params: params, callback: callback || null });
    (CONFIG.logLevel <= LOG.DEBUG) && console.log("Tasks in queue: " + taskQueue.length);
    
    if (!isTaskBusy && !isTaskDelay) {
        processTaskQueue();
    }
}

// Prosessoidaan työjono
function processTaskQueue() {
    if (isTaskBusy || taskQueue.length === 0) {
        isTaskDelay = false;
        return;
    }

    isTaskBusy = true;
    try {
        let taskToExecute = taskQueue[0];
        taskQueue.splice(0, 1); 
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("Running task: " + taskToExecute.method + " with params: " + JSON.stringify(taskToExecute.params));

        if (taskToExecute.type === "shellycall") {
            Shelly.call(taskToExecute.method, taskToExecute.params, function (res, errCode, errMsg) {
                if (taskToExecute.callback) {
                    (CONFIG.logLevel <= LOG.DEBUG) && console.log("Calling callback for " + taskToExecute.method);
                    taskToExecute.callback(res, errCode, errMsg);
                    taskToExecute.callback = null;
                } else {
                    (CONFIG.logLevel <= LOG.DEBUG) && console.log("No callback found for task: " + taskToExecute.method);
                }
                isTaskBusy = false;
                handleTaskQueueDelay(taskToExecute);
            });
        } else {
            (CONFIG.logLevel <= LOG.DEBUG) && console.log("Unknown task type: " + taskToExecute.type);
            isTaskBusy = false;
            handleTaskQueueDelay(taskToExecute);
        }
    } catch(e) {
        (CONFIG.logLevel <= LOG.ERROR) && console.log("Error with task: " + taskToExecute.method + " with params: " + JSON.stringify(taskToExecute.params) + ": " + e);
        isTaskBusy = false;
        processTaskQueue()
    }
}

function handleTaskQueueDelay(task) {
    if (taskQueue.length === 0) {
        task = null;
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("All tasks has been done.");
        
        return;
    }

    if (taskQueue[0].method === "Switch.Set" && task.method === "Switch.Set") {
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("Consecutive Switch.Set calls detected, setting a delay before the next call.");
        isTaskDelay = true;
        Timer.set(5000, false, function () {
            isTaskDelay = false;
            processTaskQueue();
        });
    } else {
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("No consecutive Switch.Set calls detected, proceeding without delay.");
        processTaskQueue();
    }
}

// Lajitellaan flat schedule-taulukko [timestamp, channel, state] aikaleiman mukaan (selection sort)
function sortFlatScheduleByTimestamp(schedule) {
    let n = schedule.length;
    for (let i = 0; i < n - 1; i++) {
        let minIndex = i;
        for (let j = i + 1; j < n; j++) {
            if (parseInt(schedule[j][0]) < parseInt(schedule[minIndex][0])) {
                minIndex = j;
            }
        }

        if (minIndex !== i) {
            let tmp = schedule[i];
            schedule[i] = schedule[minIndex];
            schedule[minIndex] = tmp;
        }
    }
    return schedule;
}

// Sähköauton latausaseman virtuaalikomponentin (kanava 201) käsittely
function HandleEvVirtualComponent(channelData) {
    // Tarkistetaan ensin, tukeeko laite virtuaalikomponentteja
    if (typeof Shelly === "undefined" || typeof Shelly.addVirtualComponent !== "function") {
        (CONFIG.logLevel <= LOG.DEBUG) && console.log("Virtual components are not supported on this firmware, skipping EV virtual switch handling.");
        return;
    }

    let evEntry = null;

    if (channelData && typeof channelData === "object") {
        for (let i = 0; i < channelData.length; i++) {
            let chEntry = channelData[i];
            if (!chEntry || chEntry.id === undefined) continue;

            let chId = parseInt(chEntry.id);
            if (chId === evVirtualChannelId) {
                evEntry = chEntry;
                break;
            }
        }
    }

    // Jos kanava 201 ei tule ohjausdatan mukana, poistetaan mahdollinen virtuaalikomponentti
    if (!evEntry) {
        if (evVirtualSwitchId !== null) {
            if (typeof Shelly.removeComponent === "function") {
                try {
                    Shelly.removeComponent(evVirtualSwitchId);
                    (CONFIG.logLevel <= LOG.INFO) && console.log("EV virtual switch removed, id: " + evVirtualSwitchId);
                } catch (e) {
                    (CONFIG.logLevel <= LOG.ERROR) && console.log("Error removing EV virtual switch: " + e);
                }
            } else {
                (CONFIG.logLevel <= LOG.WARN) && console.log("Shelly.removeComponent not available, cannot remove EV virtual switch with id: " + evVirtualSwitchId);
            }
        }

        evVirtualSwitchId = null;
        evVirtualState = null;
        evVirtualName = null;
        return;
    }

    // Täällä: ohjausdatan joukosta löytyi kanava 201
    let desiredState = 0;
    if (evEntry.state !== undefined) {
        desiredState = parseInt(evEntry.state) ? 1 : 0;
    }
    let desiredName = evEntry.name || ("EV channel " + evVirtualChannelId);

    // Luodaan virtuaalikomponentti, jos sitä ei ole vielä olemassa
    if (evVirtualSwitchId === null) {
        try {
            let cfg = { name: desiredName };
            evVirtualSwitchId = Shelly.addVirtualComponent("switch", cfg);
            evVirtualName = desiredName;
            (CONFIG.logLevel <= LOG.INFO) && console.log("EV virtual switch created, id: " + evVirtualSwitchId + ", name: " + desiredName);
        } catch (e) {
            (CONFIG.logLevel <= LOG.ERROR) && console.log("Error creating EV virtual switch: " + e);
            return;
        }
    } else if (desiredName && evVirtualName !== desiredName) {
        // Nimen mahdollinen päivitys – ei yritetä muuttaa itse komponenttia, pidetään vain kirjaa
        evVirtualName = desiredName;
    }

    // Päivitetään virtuaalikomponentin tila vain, jos se muuttuu
    if (evVirtualSwitchId !== null && (evVirtualState === null || evVirtualState !== desiredState)) {
        let onValue = desiredState === 1 ? true : false;
        enqueueTask("shellycall", "Switch.Set", { id: evVirtualSwitchId, on: onValue }, function () {
            evVirtualState = desiredState;
            (CONFIG.logLevel <= LOG.INFO) && console.log("EV virtual switch set to state: " + desiredState);
        });
    }
}

// Failsafe logic
function DoFailsafeControls() {
    return;
}

// Script cycle
function MainCycle() {
  
    (CONFIG.logLevel <= LOG.INFO) && console.log("Cycle " + mainCycleCounter + "/" + cyclesUntilRequest + " until next request.");
    
    CheckRelayStates();
    
    CheckControlData();
    
    if ((!isFailsafe) && controlsData && controlsReady) {
        DoControls();
    }
    
    if (isFailsafe) {
        DoFailsafeControls();
    }
    
    if (mainCycleCounter >= cyclesUntilRequest) {
        controlsReady = false;
        RequestControldata();
    }
    
    mainCycleCounter++;
}

// Start program
init()